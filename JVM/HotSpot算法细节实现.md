### **HotSpot算法细节实现**

#### **1. 根节点枚举（GC Roots）**

固定作为GC Roots的有虚拟机栈中的所有栈帧（当前执行的所有方法）的局部变量表的相关引用，全局性引用（类静态变量、常量）

所有收集器在做根节点枚举的时候，一定都是STW（包括CMS、G1、ZGC的低延时，也不可避免的在此处需要STW）

    可达性分析计算耗时最长的查找引用链与用户线程已经可以做到一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行

#### OopMap数据结构
目前主流的VM使用的都是**准确式垃圾收集**（可以直接知道内存中某个位置的数据具体是什么类型），所以**不需要一个不漏的检查搜索所有执行上下文和全局的引用位置**，有办法直接得到哪些地方存放着对象引用

在类加载时，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，并通过**一组**OopMap数据结构存放，收集器在扫描时可以直接得知**所有引用的位置信息**

    结构：{ebx(寄存器): Oop, [16](栈中偏移量为16): Oop， off(偏移量，即有效范围从指令开始位置 + 142位置): 142}

#### **2. 安全点**

引用关系变化（导致OopMaps）内容变化的指令众多，如果每一条指令都需要记录，则会产生大量的额外存储空间

实际上HotSpot并没有为每一条指令生成OopMap，只是在**安全点**记录了信息

1. 减少记录的频次，以减少存储空间

2. 通过safe Point的方式，使得线程挂起等待，避免GC在线程计算过程中操作到heap与stack（并发问题）

生成安全点的位置，遵循“使程序长时间运行的特征”，即指令序列复用的地方：方法调用/循环跳转/异常跳转等地方

线程是通过主动式中断的方式，设置一个中断标志位，线程在运行过程中不断轮询标志位，一旦发现中断标志位为真时就在最近的安全点上主动挂起，轮询标志的地方与安全点是重合的，并加上所有创建对象和其他需要在Java堆上分配内存的地方

    **内存保护陷阱**，当需要暂停用户线程时，将某内存页设置为不可读，那线程执行到test指令时就产生了一个自陷异常信号

#### **3. 安全区域**

在安全区域中，引用关系不会发生变化，爱这个区域中收集垃圾是安全的

当程序不执行的时，无法响应vm的中断请求，不能通过内存保护陷阱机制中断自己，此时vm也不会等待线程重新运行

当用户线程执行到安全区域里的代码时，会标识自己已经进入了安全区域，此时vm就无需等待这部分的线程，只等待处于非安全区域的所有线程进入安全点，开始进行GC

若线程被重新唤醒（此时GC可能正在运行），它需要检查vm是否已经完成了根节点枚举，若已完成则照常往下执行，若未完成则在安全区域中继续等待，直到枚举完成才可离开安全区域代码

#### **4. 记忆集与卡表**

#### 记忆集
一种用于记录从非收集区域指向收集区域的指针集合，是新生代的一个全局数据结构

实现方式：
1. 保存非收集区域中所有含跨代引用的**对象数组**
- 优点：简单
- 缺点：空间占用和维护成本高昂

2. 保存某一块非收集区域是否存在有指向收集区域的指针
精度：
- 字长精度：精确到跨代引用
- 对象精度：精确到对象
- 卡精度：**精确到一块内存区域（最常用）**

#### 卡表

卡精度是最常用的一种精度，使用Card Table实现记忆集

定义了记忆集的记录精度、与堆内存的映射关系等

    卡表最简单的方式可以只是一个字节数组：
    CARD_TABLE [this address >> 9] = 0

字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称为“卡页”，HotSpot的卡页大小为2的9次幂，即512字节

一个卡页通常包含不止一个对象，只要卡页内有一个对象有跨代引用，则将该卡页标记为1，这个卡页就变成了脏卡页（**Dirty Card**）

#### 问题：如何变脏的？



#### 问题：记忆集的卡表是否覆盖了整个老年代？

是的

GC发生时，只要筛选卡表中的脏卡页，加入到GC Roots中一并扫描即可

#### **5. 写屏障**

#### **6. 三色标记**

