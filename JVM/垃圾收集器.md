## **HotSpot经典垃圾收集器合集**

### **F大引言-HotSpot各大收集器的开发历史**

一开始只有**NewGeneration**，后来HotSpot团队准备加入young gen的并行GC：
1. 把**原本的NewGeneration改名为DefNewGeneration**
2. 并把新加入的并行版本叫**ParNewGeneration**

Parallel Scavenge开发团队不希望在HotSpot的分代式框架中憋着，自己实现了框架以外的新并行GC，结果就是HotSpot开发团队需要维护两个功能一致，但实现细节各自为盟的两个GC

Scavenge收集就是新生代的copying算法的另一种别称，**HotSpot里的所有GC都是在minor GC阶段使用scavenging**，DefNew（Serial GC）、ParNew和Parallel Scavenge都是

    把GC并行化的目的是想提高GC速度，也就是提高吞吐量（throughput）
    
    所以其实ParNew与ParallelScavenge都可叫做Throughput GC

    但是在HotSpot VM的术语里“Throughput GC”通常特指“ParallelScavenge”

Parallel Scavenge和ParNew GC都是属于并行GC，主要是并行收集**young GC**，目的和性能都差不多，最明显的区别有以下几点：
1. 遍历对象图时：Parallel Scavenge深度优先遍历，ParNew广度优先遍历
2. PS完整得实现了自适应大小策略（adaptive size policy），而ParNew及“分代式框架”内的其它GC都没有完全实现，千万不要在ParNew+CMS组合下使用该参数，该参数在CMS组合策略中默认关闭
3. ParNew可以跟CMS搭配使用，而Parallel Scavenge不行

    最初的Parallel Scavenge目标只是并行收集young gen，核心收集器在PSScavenge中，而full GC还是与Serial Old GC一致，但称为PSMarkSweep的收集器

    该收集器其实只是在Serial old gc的外表上套了一层皮，本质上还是一样的LISP2的mark-compact标记整理算法

![](https://img-blog.csdnimg.cn/20200824180142102.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNjkyOTQ=,size_16,color_FFFFFF,t_70#pic_center)
![](https://img-blog.csdnimg.cn/20200824181722627.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNjkyOTQ=,size_16,color_FFFFFF,t_70#pic_center)

### **控制吞吐量与延迟**

吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 运行垃圾收集时间）

降低整体垃圾收集时间，会增加用户代码运行的时间，在整体而言吞吐量就上去了（但也意味着单次GC的时间延迟可能会变大，高延迟会带来糟糕体验）

降低最大垃圾收集时间（单次GC时间），常会导致发生GC频率变高，使得总体垃圾收集时间占比变高，使得吞吐量下去

低延迟：服务的响应速度更快，希望系统停顿时间尽可能短

#### **1. 新生代收集器**

#### **1.1. Serial收集器（Serial Young GC）**

client模式下的默认收集器，具有额外内存小号最小，简单，与其他收集器的单程效率相比更为高效

单线程，强调它在进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束

STW是虚拟机在后台自动发起和自动完成的，在用户不可知、不可控的情况下把用户的正常工作的线程全部停掉

努力方向：降低用户线程因为垃圾收集而导致的停顿

算法：标记-复制算法，Scavenge/copying GC

#### **1.2. ParNew收集器**

实际上是Serial收集器的多线程并行版本，除了同时使用多条线程进行收集之外，其他的收集器使用参数、收集算法、Stop the World、对象分配规则、回收策略等都与SerialGC完全一致

目前与CMS搭配的唯一直选，在JDK9开始之后，直接取消使用了+XX:UseParNewGC参数，ParNewGC并入CMS，成为CMS的专门处理组成成分

默认开启的垃圾收集线程与处理核心线程数量相同，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数

实现算法：标记-复制算法，Scavenge/copying GC （并行版本）

#### **1.3. Parallel Scavenge收集器**

达到一个可控制的吞吐量，提供了两个参数精确控制吞吐量：
- -XX:MaxGCPauseMillis: 最大垃圾收集停顿时间

        范围：大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值

        停顿时间以吞吐量和新生代空间为代价换取，设置的越小，新生代空间则越小，GC发生的频率越多：

        原本10秒一次GC，一次100毫秒 -> 5秒一次GC，一次70毫秒

        =》每十秒100毫秒STW -> 每十秒140毫秒STW

        延迟降低，但吞吐量也随之变小

- -XX:GCTimeRatio：GC时间占总时间比率

        范围：0 - 100

        垃圾收集时间占总时间的比率，相当于吞吐量的倒数：值越大，则单次GC时间越小，吞吐量越低

- -XX:+UseAdaptiveSizePolicy: 自适应大小策略


实现算法：标记-复制算法，Scavenge/copying GC （并行版本）

#### **2. 老年代收集器**

HotSpot VM的GC里，除了CMS的concurrent collection之外，**其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事前触发一次young gc（除了Parallel Scavenge框架）**

#### **2.1 SerialOld**

串行化老年代收集算法

实现算法；标记-整理算法

#### **2.2 Parallel Old收集器**

并行化了老年代的标记-整理算法，不然之前用的PS MarkSweep，老年代回收效率低下，单次GC时间与总体GC时间都较大，影响了整体的吞吐量

实现算法：标记-整理算法

#### **2.3 CMS收集器**

一款以获取**最短回收停顿时间**为目标的收集器（低延迟），全称Concurrent Mark Sweep，即**并发安全**的**标记清除算法**

真正的Old GC，Full GC之下需要搭配young GC，不会去搜集整堆

#### **触发条件：**

在实现上分成 **foreground collector** 和 **background collector**。foreground collector 相对比较简单，background collector 比较复杂，情况比较多。

**foreground collector**
foreground collector 触发条件比较简单，一般是如下：
- 老年代没有足够的连续空间分配给晋升的对象（即使总可用内存足够大）
- 新生代没有足够的空间分配对象
- 老年代没有足够的剩余空间来容纳新的大对象

**background collector**
CMS 后台有一个线程每隔 CMSWaitDuration (默认时间是 2s,经常会有业务遇到频繁的 CMS GC，注意看每次 CMS GC 之间的时间间隔，如果是 2s，那基本就可以断定是 CMS 的 background collector) 时间去判断是否应该回收，是否回收条件：

- 如果开启了UseCMSInitiatingOccupancyOnly参数，判断当前老年代使用率是否大于阈值，则触发 cms gc，该阈值可以通过参数-XX:CMSInitiatingOccupancyFraction进行设置，如果没有设置，默认为92%。

运作过程分为以下四个步骤：
1. 初始标记（CMS initial mark）
    
    仅仅只是标记一下GC Roots能直接关联到的对象

2. 并发标记（CMS concurrent mark）

    从GC Roots直接关联到的对象开始遍历整个对象图的过程，耗时较长

3. 重新标记（CMS remark）

    修正并发标记时，因程序继续运作导致的标记变动，CMS使用增量更新的方式（将有新增白色对象引用的黑色对象作为根重遍历一遍）

4. 并发清除（CMS concurrent sweep）

其中初始标记和重新标记两个步骤还是需要STW

并发清理过程中不需要STW也能保证安全的原因是：

**在决定清除的那一刻已经不会有新的白色对象引用到黑色对象，因为GC Roots已经固定了，不可能再有黑色对象突然引用到白色对象上**

缺点：

1. 对处理器资源敏感，占用一部分线程导致应用程序变慢，降低总吞吐量，CMS默认启动的回收线程是（处理器核心数量 + 3） / 4，只占用不超过25%的运算资源

2. 无法处理“浮动垃圾”，即在清理的过程中可能会产生新的垃圾，所以必须预留一部分空间供并发收集时的程序运作使用

3. 标记-清除，会导致内存碎片情况严重，使得大对象分配困难，在老年代内存足够的情况下也得进行Full GC

默认搭配：ParNew + CMS

实现算法：标记-清除算法

#### **2.4 G1收集器**

**堆分布：**

在G1中堆被分成一块块大小相等的heap region，一般有2048块，这些region在逻辑上连续

每块region都有**唯一的分代标志(eden/survivor/old)**，eden region集构成Eden空间，survivor region集合构成Survivor空间，old region集合构成Old空间

    通过命令行参数-XX:NewRatio=n来配置新生代与老年代的比例，默认为2，即比例为1:2；-XX:SurvivorRatio=n则可以配置Eden与Survivor的比例，默认为8

**收集过程：**

G1保留了YGC并加上了一种全新的mixed_gc用于收集老年代。**G1中没有Full GC，G1中的Full GC是采用serial old Full GC**

G1将收集和压缩，集中在可能充满垃圾的region，使用**暂停预测模型来满足用户定义的暂停时间目标，并根据制定的暂停时间目标选择要收集的区域数量**

需要注意的是，G1不是实时收集器。它能够以较高的概率满足设定的暂停时间目标，但不是绝对确定的。根据以前收集的数据，G1估算出**在用户指定的目标时间内可以收集多少个区域**

从最高层看，G1的collector一侧其实是两个大部分：
- 全局并发标记(global concurrent marking)

    并发标记完成之后，G1知道哪些regions空闲空间多（可回收对象多），优先回收这些空region，这就是G1名字的原因

- 拷贝存活对象(evacuation)
这两部分可以相对独立的执行

#### **2.4.1 Region** 

G1中每个Region大小是固定相等的，Region的大小可以通过参数-XX:G1HeapRegionSize设定，取值范围从1M到32M，且是2的指数。如果不设定，那么G1会根据Heap大小自动决定。

    size =（堆最小值+堆最大值）/ TARGET_REGION_NUMBER(2048) ，然后size取最靠近2的幂次数值， 并将size控制在[1M,32M]之间

#### **2.4.2 Global concurrent marking**

基于SATB形式的并发标记，它具体分为下面几个阶段：

1. **初始标记（initial marking）**

    **暂停阶段**

    扫描根集合（G1的RSet是双向的，其他收集器的RSet是单向的），标记所有从根集合可直接到达的对象，压入扫描栈中等待后续扫描
    
    使用外部的marking bitmap记录mark信息，而不使用对象头的mark word的mark bit

    在分代式G1模式中，初始标记阶段**借用young gc的暂停**，因而没有额外的、单独的暂停阶段

2. 并发标记(concurrent marking)

    **并发阶段**

    不断从扫描栈取出引用递归扫描整个堆里的对象图（三色标记），**过程中还会扫描SATB Wrtie-Barrier所记录下的引用, 该过程将降低第三阶段的停顿时间**

3. 重新标记/最终标记(final markinging)

     **暂停阶段**

    处理**剩余pre-barrier记录的旧引用**，也进行弱引用处理

        G1暂停只需要扫描SATB buffer，CMS的remark会重新扫描卡表里的脏页外加整个根集合，而此时整个新生代（不管对象生死）也会被纳入根集合中

4. 清理

    **暂停阶段**

    **清点**和重置标记状态，这个阶段类似于mark-sweep的sweep，不过并没有在堆上sweep实际对象，而是在marking bitmap里**统计每个region被标记为存活的对象有多少**

    如果**region完全没有活对象的，则会将其整体回收到可分配region列表**

#### **2.4.3 Evaluation**

**该过程不需要依赖global concurrent marking的统计结果，有就用，没有就自己从根节点遍历对象图**

    全暂停，将一部分region里的活对象拷贝到空region里去，然后回收原本的region空间

    可任意选择多个region来独立收集（Collection Set，简称CSet），CSet靠per-region remembered set实现（RSet）实现，因为每个region都有一个RSet

    选定CSet后，evaluation跟PS scavenge类似，把活对象拷贝到新region（依赖异步的global concurrent mark得到的clean结果，清点每个region的存活对象）

    CSet的选定，永远都会包含young gen的对象（G1每个region都会RSet，不像其他只有新生代有RSet），所以不会维护从young gen region出发的引用涉及到的RSet更新

#### **2.4.4 运作模式**

- YGC：选定所有新生代的region，通过控制young gen的region个数来控制YGC开销
- Mixed GC：选定所有新生代的region，外加全局并发标记的清理阶段得出的收集收益最高的几块old region

**根据用户制定开销范围内，回收收益最高的region**

分代式G1的正常工作流程，就是在YGC和mixed GC之间视情况切换

异步定期做全局并发标记，initial marking默认搭在ygc上执行，当全局并发标记正在工作时，G1不会选择mixed gc，反之有mixed gc在执行，也不会启动initial marking

如果mixedgc无法跟上程序分配内存的速率，则会触发一次serial old gc，进行一次full gc

### 总结
young gen的标记回收策略都是：标记-复制算法（copying/scavenge）

-XX:+UseSerialGC: 

    串行化SerialGC + 串行化Serial Old GC（mark-compact）

    client模式下的默认回收策略

-XX:+UseConcurrentMarkSweep: 

    并行化ParNewGC + 并发CMSGC（mark-sweep）

    第一款并发GC，专注于低延迟

-XX:+UseParallelGC/-XX:+UseParallelOldGC: 

    并行化PS Scavenge + 串行化PS MarkSweep/串行化PS Compact（mark-compact）

    吞吐量优先组合，老年代都是标记-整理算法

-XX:+UseG1GC

# 参考

- [深入理解JVM-3.5节经典垃圾收集器]()
- [HotSpot VM的开发历史和实现细节](https://hllvm-group.iteye.com/group/topic/37095#post-242695)
- [CMS触发条件](https://blog.csdn.net/ryanqy/article/details/104946950)