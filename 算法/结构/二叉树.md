# 二叉树

> [TreeMap](https://asea-cch.life/achrives/treemap)

树是范畴更广的图的特例，它的顶部小，底部大，就像颠倒的真实树，程序一般都从树的小的那端开始执行操作

在树的顶层总是只有一个节点，它通过边连接到下一层的多个节点，依次类推连接下去n层

树有很多种，不同的树可以拥有的子节点树个数不同。一般而言，超过2个子节点的树，称为**多路树**；而二叉树顾名思义，就是子节点最多不超过2个的树

# **1. 基本结构**

二叉树的基本术语：

- 路径

    **从顶向下**，从某个节点顺着连接的边，走到下一个节点的顺序排列称为路径

- 根节点

    树的顶端节点，一颗树只有一个根
    
        顺着根到某个节点的路径有且只有一个；路径多个的称为图

- 父节点

    相对而言：某个节点B都有**向上连接**到的另一个节点A，A节点就是B的父节点

        根节点没有父节点，或者说其父节点为NULL

- 子节点/叶子节点

    相对而言：某个节点A如果有**向下连接**的其他节点B、C，则B、C节点称为A节点的**子节点**；如果没有的话，称为**叶子节点**；

        叶子节点没有子节点，或者说其子节点为NULL

- 子树

    每个节点，及其以下的子节点、孙子节点、孙子节点的子节点等等所构成的集合，称为子树

- 层数/高度

    一个节点的层数/高度，指的是根到该节点有多少“代”，具体看根节点是第一层还是第零层

- 深度

    在整棵树中，层数最高的叶子节点，其层数即为整棵树的深度

# **2. 二叉搜索树**

二叉搜索树规则：

    任意节点的左子节点的关键字值都小于该父节点，右子节点的关键字值大于或等于该父节点

一般提到二叉树，就是说的二叉搜索树，没有按照二叉搜索树规则排列节点的树没有真实意义。下面列举多个二叉搜索树的基本操作来进行说明

# **3. 基本操作**

    插入/查找/删除操作，起点都是根节点；而遍历则根据不同的方式，有不同的起点

操作行走准则：

都是依据给定的值，与节点的值进行对比，如果**大于节点值则右走；小于节点值则左走**

当前节点(current)：

指当前操作引用所处于的节点

## **3.1 查找**

起点为根节点，所以第一个当前节点为根节点，以给定值与当前节点值做对比：

- 如果相等，则查找成功

- 如果不相等，则根据如上路径行走准则往子节点行走

    - 如果有路径，则继续行走，并修改当前节点为行走至的节点

    - 如果没有路径，说明该路径已走完，查找失败

成功返回当前节点，失败返回NULL

### **效率**

时间取决于查找的**节点所处层数**

如果有31个节点，则二叉树的层数最多不超过5层，所以查找次数最多不超过5次

    时间复杂度：O(logN)

## **3.2 插入**

在查找插入位置时，每到达一个节点，如果该节点没有下一个行走路径了，则**以当前节点作为父节点，按对比的结果将新节点作为其左/右子节点**

### **效率**

像是查找一个一定不存在的节点的过程，并多一步插入的操作：

- 在插入未有的值时，效率与查找不存在节点的效率一样，即logN + 1
- 在插入已有的值时，会往右路径走最多不超过5层的，即2 * (logN) + 1

    时间复杂度：O(logN)

## **3.3 删除**

## **3.4 遍历**

### **3.4.1 中序**

### **3.4.2 前/后序**

# **4. 什么时候用二叉树（二叉树的好处）**

# 参考
- [Java数据结构与算法（第二版）第八章：二叉树]()