### **HotSpot算法细节实现**

#### **1. 根节点枚举（GC Roots）**

固定作为GC Roots的有虚拟机栈中的所有栈帧（当前执行的所有方法）的局部变量表的相关引用，全局性引用（类静态变量、常量）

所有收集器在做根节点枚举的时候，一定都是STW（包括CMS、G1、ZGC的低延时，也不可避免的在此处需要STW）

    可达性分析计算耗时最长的查找引用链与用户线程已经可以做到一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行

#### OopMap数据结构
目前主流的VM使用的都是**准确式垃圾收集**（可以直接知道内存中某个位置的数据具体是什么类型），所以**不需要一个不漏的检查搜索所有执行上下文和全局的引用位置**，有办法直接得到哪些地方存放着对象引用

在类加载时，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，并通过**一组**OopMap数据结构存放，收集器在扫描时可以直接得知**所有引用的位置信息**

    结构：{ebx(寄存器): Oop, [16](栈中偏移量为16): Oop， off(偏移量，即有效范围从指令开始位置 + 142位置): 142}

#### **2. 安全点**

引用关系变化（导致OopMaps）内容变化的指令众多，如果每一条指令都需要记录，则会产生大量的额外存储空间与**修改代价**（深入理解JVM的作者只说存储空间，容易让人误解）

实际上HotSpot并没有为每一条指令生成OopMap，只是在**安全点**记录了信息（在安全点才**统一对OopMap进行一次更新**），**这也使得SafePoint处的OopMap一定是准确的，因此只能在安全点处进行GC**

**这也意味着，用户线程并不能在代码指令流的任意位置停下来，进行GC，需要执行到代码安全点处（安全点）**

1. 减少记录的频次，以减少存储空间

2. 通过safe Point的方式，使得线程挂起等待，避免GC在线程计算过程中操作到heap与stack（并发问题）

生成安全点的位置，遵循“使程序长时间运行的特征”，即指令序列复用的地方：方法调用/循环跳转/异常跳转等地方

线程是通过主动式中断的方式，设置一个中断标志位，线程在运行过程中不断轮询标志位，一旦发现中断标志位为真时就在最近的安全点上主动挂起，轮询标志的地方与安全点是重合的，并加上所有创建对象和其他需要在Java堆上分配内存的地方

    **内存保护陷阱**，当需要暂停用户线程时，将某内存页设置为不可读，那线程执行到test指令时就产生了一个自陷异常信号

#### **3. 安全区域**

当程序不执行的时，无法响应vm的中断请求（不能通过内存保护陷阱机制中断自己），此时vm也**不会等待处于安全区域的线程重新运行到安全点**（没有处于安全区域的线程就需要等待）

在安全区域中，引用关系不会发生变化，**在这个区域中收集垃圾是安全**的

当用户线程执行到安全区域里的代码时，会标识自己已经进入了安全区域，此时vm就无需等待这部分的线程，只等待处于非安全区域的所有线程进入安全点，开始进行GC

若线程被重新唤醒（此时GC可能正在运行），它需要检查vm是否已经完成了根节点枚举，若已完成则照常往下执行，若未完成则在安全区域中继续等待，直到枚举完成才可离开安全区域代码  

#### **4. 记忆集与卡表**

**Card Table是Remembered Set的一种实现**

#### 记忆集
一种用于记录从非收集区域指向收集区域的指针集合，是新生代的一个全局数据结构

用途：用于避免将整个老年代加入到GC Roots的扫描范围

实现方式：
1. 保存非收集区域中所有含跨代引用的**对象数组**
- 优点：简单
- 缺点：空间占用和维护成本高昂

2. 保存某一块非收集区域是否存在有指向收集区域的指针
精度：
- 字长精度：精确到跨代引用
- 对象精度：精确到对象
- 卡精度：**精确到一块内存区域（最常用）**

#### 卡表

卡精度是最常用的一种精度，使用Card Table实现记忆集

定义了记忆集的记录精度、与堆内存的映射关系等

    卡表最简单的方式可以只是一个字节数组：
    CARD_TABLE [this address >> 9] = 0

字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称为“卡页”，HotSpot的卡页大小为2的9次幂，即512字节

一个卡页通常包含不止一个对象，只要卡页内有一个对象有跨代引用，则将该卡页标记为1，这个卡页就变成了脏卡页（**Dirty Card**）

#### 问题：何时变脏？如何变脏的？

何时变脏：
答：卡表写标记的时机，是在**给老年代对象的引用类型实例变量赋值时**，只要有引用指向年轻代的对象，则将该页记录为脏页

如何变脏（如何维护卡表）：

    tips：如果是解释执行的字节码，JVM将有充分的介入空间，在负责每条字节码执行的时候其维护，但Java是编译执行的

答：编译执行后，获得的是纯粹的机器指令流，必须在**机器码层面**上用手段去把维护卡表的**操作放到每一个赋值操作**中，这个操作的实现方式就是**写屏障**

通过写后屏障操作维护卡表的信息: post_write_barrier(field, new_value);

#### 问题：记忆集的卡表是否覆盖了整个老年代？

是的

GC发生时，只要筛选卡表中的脏卡页，加入到GC Roots中一并扫描即可

#### **5. 写屏障**

这个写屏障与以下的屏障需要区分开来：
- 低延迟收集器的读屏障
- 解决并发乱序执行（指令重排序）的内存屏障区

写屏障可以看作在**虚拟机层面**是“引用字段赋值“这个动作的AOP切面，在引用对象赋值时产生一个**环形通知**，供程序执行额外的操作

**即赋值前后都在写屏障的覆盖范畴内，在赋值前的部分写屏障叫做写前屏障，在赋值后的叫做写后屏障**（直至G1收集器出现之前，其他收集都只用到了写后屏障）
- Pre-barrier：写前屏障(目前G1用了，因为SATB需要记录旧的引用值,在post-write-barrier取不到旧值)
- Post-barrier：写后屏障

    void oop_field_store(oop* field, oop new_value) {
        // 写前屏障
        pre_write_barrier();

        // 引用字段赋值操作
        *field = new_value;
        
        // 写后屏障
        post_write_barrier(field, new_value);
    }

问题1: 写屏障的花销
（每次赋值引用时触发屏障 + GC更新卡表触发屏障）
应用写屏障后，虚拟机就会为所有赋值操作生成响应的屏障指令，一旦收集器在写屏障中增加了更新卡表操作，无论回收的是不是新生代的还是老年代的，**只要对卡表进行更新**，就都会产出一次修改卡表的花销：

    *field = null;
    post_write_barrier(field, null); // 额外花销

    但该花销比扫描时加入整个老年代小

问题2: 写屏障引入的“伪共享”

在高并发场景下会出现伪共享问题，现代CPU缓存系统是以缓存行（Cache Line）为单位存储的，当多线程互相修改自己变量时，如果这些变量恰好共享一个缓存行，那么会彼此影响（写回、失效、同步），导致性能下降

    假设一个缓存行的大小是64Kb，一个卡表的单元素大小为1KB（标记值，不是卡页对应的内存大小），那么该卡表的64个卡表元素将共享这个缓存行；这64个卡表元素对应了：
    64 * 512字节（HotSpot的卡页大小为2的9次幂，即512字节） = 32KB的内存区域，若不同线程更新的对象就在该区域，则出现伪共享问题

    解决方式：在标记为脏页时，增加条件判断 -- 先检查是否已经变脏，防止失败（之前是无条件）

    -XX:+UseCondCardMark, 用来决定是否开启卡表更新的判断条件

#### **6. 三色标记（引入了后续低延时收集器）**

由于GC Roots相比起整个Java堆对象算是少数，且在OopMap技巧加持下，它带来的停顿已经不随着堆容量而增长了，即**GC Roots的获取难度不会轻易随着堆容量增长而提升**

但**从GC Roots往下遍历对象图，这一步骤的停顿时间就必然会与堆容量成正比**，标记是所有tracing GC的共同特征（如果能削减掉部分的遍历标记开销，对于所有标记算法带来的收益巨大）

在想要降低用户线程的停顿，则要先搞清楚**必须在一个保证一致性的快照上，才能进行对象图的遍历（标记），此处要区分开根节点枚举必须STW，与标记过程可以做到与用户线程并发处理，这两个概念**

#### **三色标记辅助推导：为什么必须在一个能保障一致性的快照上才能进行对象图的遍历**
1. 白色标记
    
    表示对象尚未被垃圾收集器访问过，显然在可达性分析的开始阶段，所有对象都是白色的；在分析结束后，仍为白色的，则为需要被回收的对象

2. 黑色标记

    已经被垃圾收集器访问过，且这个对象的所有引用都已扫描过，它是安全存活的，如果有其他对象指引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向白色对象

    tips：容易误解的点，白色指向黑色（不用再向下遍历了，白色与之后的对象图都应该回收），黑色指向白色（白色也是需要存活的对象）

3. 灰色标记

    表示对象已经被垃圾收集器访问过，但这个对象至少存在一个引用还没有被扫描过

可以把标记过程的对象图看成：黑向白的推进过程（处于遍历分支过程中的节点为灰色）

这可能会导致：
- 原本存活的对象，被并发的用户线程修改了引用关系，变成了已经遍历过的之前的黑色节点的分支（即仍然存活，也应该被标记为黑色，却被标记为白色），将会导致问题

    当且仅当以下两个条件同时满足时，会产生对象消失的问题：
    - 赋值器插入了一条或多条**从黑色对象**到白色对象的新引用
    
        白色对象还在被使用，关注的主体是黑色对象
    
    - 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用 
    
        白色对象无法再被探测到，关注的主题是被删除的对白色对象的引用

- 原本在本次GC遍历中不该存活的对象，被并发的用户线程重新建立了引用，产生了浮动垃圾（问题不大）

第一个问题的场景下，满足两个必死前置条件，会使得程序出现不可控的问题，所以只要破坏两个必死前置条件之一，即可破招：
- 增量更新（Incremental Update）

    CMS的并发标记使用该方式

    该方式破坏了第一个条件，使得黑色对象会变成灰色对象重新进行分析，即变成灰色对象到白色对象

    当黑色对象插入新的白色对象引用时，将新插入的引用记录下来，等并发扫描结束后，再将这些记录过引用关系中的黑色对象作为根，重遍历一遍，即将**黑色对象变成灰色对象**

- 原始快照（SATB，SnapShot at the beginning）

    G1的全局并发标记使用该方式

    破坏的是第二个条件，使得被干掉的引用关系，能被Write-Barrier记录下重新进行遍历

    当灰色对象要删除指向白色对象的引用时，将这个要删除的引用与关系图留下来，并发标记结束后，再照着这些灰色对象，作为根重新扫描一次刚刚的关系图，这样就保证了刚刚的引用一定能在调用链上

    通过Write-Barrier的pre切面实现，在工作线程修改引用关系时，会把引用推到gc遍历执行的堆栈上，保证还能遍历到之前的关系，以还原当时的快照样子

    ![](https://pic1.zhimg.com/80/v2-f05ea3f9902d1e0e1e6ead75b7f56428_1440w.jpg?source=1940ef5c)

    ![](https://pic1.zhimg.com/80/v2-025ff8765b94c496535534c8cc113b1c_1440w.jpg?source=1940ef5c)

    ![](https://pic1.zhimg.com/80/v2-66bbae1fe5618ff990ba5e2a24a4254f_1440w.jpg?source=1940ef5c)

    ![](https://pic4.zhimg.com/80/v2-40b2dc65d1d271647629f0fd48c265a5_1440w.jpg?source=1940ef5c)

    ![](https://pic1.zhimg.com/80/v2-718ed1052273be20f71c14a5eb597b72_1440w.jpg?source=1940ef5c)

    新对象关系全部标记为黑色，删除引用关系的白色对象变成灰色对象集，并在并发标记过程结束后重新遍历该集，遍历的子节点与该节点都会变成黑色

    也可以理解为无论引用修改与否，都会按照刚刚开始扫描那一刻的对象图快照，根据灰色节点集来进行搜索

    该方式破坏了第二个条件，G1的并发标记使用该方式  

## 总结

1. 如何发起内存回收

第1、2、3点介绍了：根节点枚举、安全点、安全区域

内存保护陷阱, 线程都走到安全点处时进行GC回收，没有执行的线程且在安全区域中的，vm可以直接跳过不等待，而该线程唤醒执行时也要等待vm的根节点枚举完成

2. 根节点枚举加速

第1、4、5点介绍了：根节点枚举记忆集、卡表、脏卡表、以及帮助维护卡表的写屏障

OopMap: 加速根节点枚举直接获得全部对象引用，无须去遍历所有堆对象

写屏障: 加速根节点枚举中的跨代引用获取的问题，同时写屏障也引入了CPU缓存行伪共享问题和每次操作都会附带一次花销的问题

3. 第6点介绍了三色标记，引入了并发可达性分析会出现的问题：对象错误消失或浮动垃圾

介绍了两个必死前置条件：赋值器插入了一条或多条黑色对象到白色对象的引用/赋值器删除了灰色对象到该白色对象的所有直接或间接引用

解决方式：使任一条件失效，实现有：增量更新和原始快照

# 参考
- [原始快照的标记方式](https://www.zhihu.com/question/406277136)
- [并发的可达性分析](https://www.cnblogs.com/thisiswhy/p/12354864.html)