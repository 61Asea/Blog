# 类加载机制

定义：

vm将描述类的数据从Class文件加载到内存中，并对数据进行校验、转换解析和初始化，最终形成可以被vm直接使用的Java类型

动态加载/连接：

加载、连接和初始化，都是在**程序运行期间完成**，这种策略使得提前编译变得困难（方法区静态变量池存放两大类常量），使得类加载时会稍微增加性能开销（静态常量池数据存入运行时常量池，以及加载、连接和初始化），但是却提供了灵活性和扩展性

**动态扩展：**

Java天生可以**动态扩展**的语言特性，就是依赖运行期**动态加载和动态连接**这个特点实现的，面向接口的程序可以在运行时再指定其实际的实现类，用户可以通过Java预置的或类自定义加载器，让某个在本地的应用程序在运行时从网络或从其他地方加载一个二进制流作为程序代码的一部分

## 1. 类加载时机

按部就班**开始**：

加载/连接/初始化都是在**程序运行期间完成的**，**加载、验证、准备、初始化、卸载**这个5个阶段的顺序是确定的，类的加载必须严格按照这种顺序开始。而在这个顺序中的各个阶段，通常是混合交叉进行，会在一个阶段执行的过程中，调用激活另一个阶段。但整体上看，其他阶段的最终还是需要上个阶段的完成。

解析阶段可以在初始化之后再开始，这是为了**支持Java的运行时绑定（动态绑定｜晚期绑定）**

### 1.1 主动引用的6种情况（必须初始化）

虚拟机的具体实现会自由**把握类加载过程的加载阶段**，但是对于**初始化阶段（加载、验证、准备需要在此之前开始）**

严格规定了有且只有6种情况必须立即对类型进行“初始化”：
- 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段
    - new：使用new关键字实例化对象时
    - getstatic/putstatic：读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候
    - invokestatic: 调用一个类的静态方法时
- 使用反射包对类型进行反射调用时，没有被初始化过，则先触发其初始化
- 初始化类时（一般从第一种情况而来），发现父类还没有进行过初始化，则需要先触发其父类的初始化
- vm启动时，需要指定main主类，vm也会先初始化该主入口类
- 动态语言支持（不管）
- 定义default接口方法的接口，其实现类发生了初始化时，接口应先被初始化

### 1.2 被动引用

以上六个阶段都属于主动引用，**除此之外，所有引用类型的方式都不会触发初始化，称为被动引用**

```java
/**
*  被动引用：
*  1. 通过子类引用父类的静态字段，不会导致子类的初始化(参考Main类main方法的最终结果)
*  2. 通过数组定义来引用类，不会触发此类的初始化
*  3. 常量（final static）在编译阶段会存入调用类的常量池，本质上没有引用到类
*/

public class SuperClass {
    static {
        System.out.println("SuperClass init");
    }

    public static int value = 123;
}


public class SubClass extends SuperClass {
    static {
        System.out.println("subClass init");
    }

    // public static int value = 234;

    // public final static int value = 345;

    public static void main(String[] args) {
        // 因为SubClass作为程序的main类，vm会初始化SubClass
        System.out.println(SubClass.value);
        // SuperClass init 
        // subClass init
        // 123
    }
}

public class Main {
    public static void main(String[] args) {
        System.out.println(SubClass.value);
        // 如果SubClass没有定义value静态字段，引用父类字段，getstatic只会读取到父类的静态字段，方法输出为：
        // SuperClass init
        // 123

        // 如果SubClass定义了value静态字段，属于主动引用，输出为：
        // SuperClass init -> 对应主动引用第三点
        // SubClass init -> 对应主动引用的第一点getstatic字节码指令
        // 234

        // 如果SubClass定义了value静态字段，但是又使用final修饰，即在编译时已加入静态变量池，则输出为：
        // 345 -> final修饰，getstatic字节码指令不会选择初始化子类，也使得主动引用第三点的父类加载消失

        SuperClass[] superClasses = new SuperClass[10];
        // 没有输出，触发的是[xxx.xxxx.SuperClass的类初始化阶段，由虚拟机自动生成、直接继承于Object的子类，由字节码指令newarray触发
        // 这个过程会对SuperClass进行加载，但是不会初始化
    }
}
```

## 2. 类的生命周期

一个类型从被加载到vm内存中，到被卸载出内存为止，生命周期为：**加载、验证、准备、解析、初始化、使用和卸载共七个阶段，其中验证、准备、解析统称为连接**

## 2.1 加载（可参考ClassLoader的loadClass方法）

- 通过一个类的全限定名将类二进制字节流流加载到内存，**这一步需要验证阶段的文件格式校验**
- 将字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 并在内存中生成一个java.lang.Class对象，作为**方法区这个类的各种数据访问入口**

    知识点：方法区运行时常量池和静态常量池的区别，静态常量池在编译的时候存放类的字面量和符号引用，在**类加载时**，静态常量池的数据会存入到运行时常量池中

    常量池存放：类名/类访问修饰符/常量池/字段描述/方法描述

二进制字节流没有规定必须从某个Class文件中获取，通过这个空隙创造了很多不同的读取方式：
- 从Zip包获取（Jar、War、Ear）
- 从网络获取，如Netty和Web Applet
- 运行时计算生成，如动态代理cglib等
- 其他文件生成，如Jsp
- 从加密Class文件中获取生成

加载阶段可以通过内置vm或者用户自定义类加载器进行加载，开发人员可以通过重写类加载器的loadClass()或findClass()方法，赋予程序获取运行代码的动态性

    数组类本身不通过类加载器创建，由vm直接在内存下动态构造出来，但数组的元素类型还是需要通过类加载器来进行完成加载

**加载阶段结束后，二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储结构由vm自行实现定义**，vm会在**堆内存下实例化一个Class对象**，该对象将作为程序访问方法区中的类型数据和外部接口

加载过程和连接过程是交叉进行的，在加载过程中的文件格式校验中需要连接的验证阶段

## 2.2 连接
### 2.2.1 验证

类二进制字节流数据，可以是从任何地方产出的，需要对其进行验证才能保证vm的的必要措施

以下的验证都是通过二进制字节流，当通过文件格式验证后，字节流才会被加载到内存中。后三个阶段都是基于内存（方法区的存储结构上）

只有第一个验证需要操作字节流，其他的验证都直接读取方法区上类的运行时存储结构
- 文件格式验证

    验证魔数、主次版本号是否vm可接受，是否有不存在或不符合类型的常量

- 元数据验证

    验证元数据信息的语言校验，包含检查：没有父类，final类被继承，抽象/接口类没重写所有方法，重写出现参数/返回不一致问题

- 字节码验证

    通过数据流分析和控制流分析

- 符号引用验证

    将符号引用转化为直接引用，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外的各类信息进行匹配性校验，确保解析阶段的正常执行

### 2.2.2 准备

正式为类变量分配内存并设置类变量初始值，这些变量所使用的内存都将在方法区中分配

这时候进行内存分配的仅包括类变量（被static修饰的变量），不包括实例变量，实例对象会随着对象实例化（初始化）随着对象一起分配到堆中

```java

// 准备阶段过后初始值为0
public static int value = 123;

// 准备阶段过后初始值为123
public final static int value = 123;

```

一般情况，会把设置value为123的putstatic指令存放于类构造器\<clinit>()方法中，在类的初始化阶段才会进行复制

但常量会被生成ConstantValue属性，在准备阶段可以直接设置值

### 2.2.3 解析

将Java虚拟机常量池内的符号引用替换为直接引用的过程

invokedynamic指令的解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行

1）类或接口的解析

假设当前代码所处的类为D，需要把一个符号引用N解析为类C或接口C：
- 如果C不是数组类型，则交给D的类加载器，通过类的全限定名进行加载
- 如果C是数组类型，N则会由vm变成[N的描述符，再根据上述规则，将元素类型加载出来

2）字段解析

对字段表内的class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是上述第一步的字段所属的类或接口的符号引用，如果解析成功得到C，将对C进行后续字段的搜索

- 如果C本身就包含了字段描述符和名称相匹配的字段，直接返回该字段（子类）
- 如果C实现了接口，会根据继承关系从下往上递归搜索了各个接口和父接口（接口实现）
- 如果C有父类继承关系，从父类上递归搜索（父类）

3）方法解析

同上，因为是具体方法，所以C不能是接口类型的

并且第二部的搜索父接口和接口列表，是针对C是类形式的搜索，若有搜索到C有相匹配的，则说明C是一个抽象类，直接抛出抽象方法异常即可

4）接口方法解析

与第三点相反，因为是接口方法，所以C不能是类形式的

## 2.3 初始化

类加载过程的最后一个步骤，除了在加载阶段可以显式指定类加载器，其他阶段都交由了vm进行处理，知道初始化阶段，vm才真正开始执行类中编写的Java程序代码

\<clinit>()方法中，对类变量进行真正的赋值，并在\<init>()方法中，根据是否类构造器有赋值，对类成员变量进行赋值，若无赋值动作则采用类型默认值

    <clinit>()方法是编译器自动收集所有static块和类变量赋值动作进行合并生成的，编译器收集的顺序是由语句在源文件

    static块只能访问到定义在static块前的变量，定义在其之后的变量，可以赋值，但不能访问

1） \<clinit>()方法于类的构造函数不同，它不需要显式调用父类构造器，会保证子类的\<clinit>()方法被执行前，父类的\<clinit>()方法已经执行完毕

2）vm会保证一个类的\<clinit>()方法在多线程中被正确地加锁同步，如果多个线程前初始化一个类，那么只会有其中一个执行该类的\<clinit>()方法，如果有一个类有耗时很长的操作，则其他线程会出现阻塞（当某线程完成，其他线程唤醒后不会再进入\<clinit>()）

## 3. 双亲委托机制

# 参考
- [Java动态扩展](https://blog.csdn.net/fanxiaogang/article/details/5425284)
- [符号引用和直接引用](https://www.cnblogs.com/shinubi/articles/6116993.html)
- [类变量、成员变量和局部变量的初始值](https://blog.csdn.net/liufangbaishi2014/article/details/86213846)