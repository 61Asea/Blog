# Mysql（三）：锁机制

这篇文章也不仅仅是对于Mysql而言，它同样也涵盖了大部分数据库的锁机制

    合理地运用各种锁概念，并将它们形成多套方案，这些方案就是各大数据库其对应的隔离级别实现

> [Mysql（五）：隔离级别](https://asea-cch.life/achrives/Mysql隔离级别)

以下根据不同层面来对锁专业名词进行分类：

- `锁资源方式`：**两段封锁（2PL）**、基于2PL的一次封锁和顺序封锁

- `锁粒度`：表级锁、**行级锁**、页级锁

- `锁级别`：**共享锁（S）**、**排他锁（X）**

- 加锁方式：自动锁、显式锁

- 使用方式：乐观锁、悲观锁

- sql语言类型：DML（数据操作语言）锁、DDL（数据定义语言）锁

目前大部分DBS都采用`2PL`来满足并发操作的可串行化调度，并根据**锁粒度**和**封锁协议**的方式来调整数据库系统的并发性能

本文将先着重以这三个作为切入点，讲述如Mysql的大部分数据库基础锁机制，再讲述Mysql如何使用其特性（MVCC，间隙锁Next-Key Lock）来更大程度地提升DBS的**并发程度**和**数据一致性**

# **1. 锁资源方式**

在讲到2PL与三级封锁协议时，总是会因为它们都带有一个封锁而混淆，注意两者切入点并不相同，前者是强调对于锁资源的方式，而后者强调锁的级别

2PL还很容易与表锁/行锁的死锁问题做混淆，这个混淆点在于表锁和行锁虽都符合2PL范式，但其锁的资源量级不同，才使得两者的死锁情况不同

## **1.1 2PL**

> [2PL](https://blog.csdn.net/aigoogle/article/details/25804285?locationNum=6&fps=1)

2PL，又称两段锁或二次封锁，它强调锁资源不是一次完成的，分为**扩展**和**收缩**两个阶段，扩展阶段只能加锁不能释放锁，收缩阶段只能释放锁不能再加锁，即扩展阶段和收缩阶段不可交替执行

事务的第一个加锁操作意味着进入了扩展阶段，收缩阶段同理

<!-- 在扩展阶段，对全部需要的数据项进行加锁操作，不允许对已经加锁的数据进行解锁。收缩阶段同理，即扩展阶段和收缩阶段不可交替执行 -->

    2PL中，收缩阶段对全部锁资源的释放可以不是一次性的，释放之中可以穿插一些除了加锁以外的的操作，扩展阶段同理

    这也意味着有其他事务在本事务进入收缩阶段后，可以立即获得已释放的锁资源

![2PL](https://asea-cch.life/upload/2021/06/2PL-39de6c5605a1447394e7d0c62514f76c.jpg)

效果：对于遵循两段锁协议的事务，其交叉并发操作的执行结果一定是正确的

遗留问题：

- 死锁

    并发的事务（遵循2PL），在扩展阶段可能会**对多个锁资源的获取**，以**不恰当的顺序对相同的多个锁资源进行竞争**，就有可能发生死锁情况

- 级联中止

    其他事务在本事务进入收缩阶段后，可以立即获得本事务已释放的锁资源，当本事务最终并未提交而选择回滚时，为了保持一致性，其他事务也会因此终止回滚

    ![2PL的级联中止](https://asea-cch.life/upload/2021/06/2PL%E7%9A%84%E7%BA%A7%E8%81%94%E4%B8%AD%E6%AD%A2-a5107b59462a452db1c88baece5fa74f.png)

## **1.2 S2PL/SS2PL**

> [严格二段锁协议实现](https://blog.csdn.net/qq_37904988/article/details/105116789)

在上文中，重点提到S2PL定义的事务执行过程，不能立刻释放锁，必须**要等待整个事务提交或回滚后，才能释放锁**，即没有像普通2PL那样的收缩阶段，不会导致级联终止的情况

![S2PL](https://asea-cch.life/upload/2021/06/S2PL-fb94caefa0c040009f2ea11e27742602.png)

> [知乎用户陈广胜的回答](https://www.zhihu.com/question/39447427)

S2PL(Strict 2PL)：在2PL的基础上，将写锁保持到事务结束

SS2PL(Strong 2PL)：在2PL的基础上，读/写锁都保持到事务结束为止

## **1.3 一次封锁/顺序封锁**

> [《数据库知识整理 - 并发控制（封锁、两段锁协议、意向锁）》](https://blog.csdn.net/Ha1f_Awake/article/details/84994697)这篇文章总结了解决死锁的两类方法：预防和诊断解除

预防的方式有两种：

- 一次封锁法：每个事务一次性将要使用的**所有资源锁定**，数据要么全部锁定，要么全部失败
- 顺序封锁法：预先对数据**规定封锁顺序**，所有事务按照这个顺序加锁

第一种方法通过将对多个锁资源的锁定视作原子操作来解决问题，第二种方法则以固定顺序获取的方式防止闭环

    2.1的表锁，就是一次封锁的一种思路：行锁可以认为是多个锁资源，获取表锁，则相当于一次封锁了全部锁资源

# **2. 锁粒度**

粒度从大到小：表级锁 -> 页面锁 -> 表级锁

- Myisam和Memory引擎：采用表级锁

- BDB引擎：采用页面锁或表级锁（默认页面锁）

- **InnoDB引擎：采用行级锁和表级锁（默认行级锁）**

## **2.1 表锁**

定义：锁定粒度最大，表示对当前**操作的整张表加锁**，分为`表共享读锁（共享锁）`和`表独占写锁（排他锁）`

开销：操作简单，开销最小

死锁情况：不会出现死锁情况，因为粒度为**单个表**，即采用**一次封锁方式**

并发程度：**并发度最差**，因为一次性将资源锁定，要么**全部满足，要么全部等待**

## **2.2 行锁**

定义：锁定粒度最细，表示只针对当前操作的行进行加锁，分为`行共享读锁`和`行独占写锁`

开销：操作复杂，开销最大（涉及到数据筛选）

死锁情况：会出现死锁的情况，因为粒度为**多个行**，且没有硬性控制并发事务对资源的访问顺序，存在死锁的可能性

并发程度：**并发性能最好**，因为发生锁竞争的概率降低了

## **2.3 InnoDB对表锁和行锁的运用**

InnoDB的行锁是通过给索引上的索引项加锁来实现的，这意味着：

- **只有通过索引条件检索数据，InnoDB才可能使用行级锁，否则，InnoDB将使用表锁**
- 最终的加锁情况，由SQL执行优化器决定，如果走的是**全表扫描，就算有索引，也是锁的整个表**
- 锁的是索引，所以即使访问的是不同的行数据，也会因为相同的索引键被锁住
- 表有多个索引时，不同事务可以使用不同的索引来锁定不同的行

行锁可以生效的索引类型有：主键索引、唯一索引、普通索引

# **3. 锁级别**

为了进一步提升并发能力，按照级别将锁分为读锁和写锁，这种思想在很多地方都有体现

> JDK中的[ReentrantReadWriteLock](https://asea-cch.life/achrives/reentrantReadWriteLock)，借助AQS实现的读写锁，相比独占锁可以提升读的效率

InnoDB以行锁粒度，运用封锁协议，以支持不同的事务隔离级别

## **3.1 共享读锁(S)**

英文全称Share Lock，又称为S锁（来源Share的字母S）或读锁，是读取操作时候创建的锁。
数据被加上S锁后，其他事务的修改操作（对数据加X锁）都将阻塞，直至所有的S锁都被释放为止

    S锁与S锁不互斥，与X类型封锁互斥 -> 读读不互斥

作用：并发读提升读效率

缺点：可能会导致写操作饥饿

## **3.2 独占写锁(X)**

英文全称Exclusive Lock，又称为X锁（来源Exclusive的字母X）、写锁或排他锁，是写操作时创建的锁。
数组被加上X锁后，其他事务的修改操作（对数据加X锁）或读取操作（对数据加S锁）都将阻塞，直至本事务将X锁释放为止

    X锁与任意类型的封锁都互斥 -> 读写互斥，写写互斥

## **3.3 意向锁(IS/IX)**



## **3.4 三级封锁协议**

封锁协议，指的是通过对两种不同类型的封锁的运用，以解决不同的数据一致性问题，可以与事务的隔离级别进行大致对应

一致性问题呈向下包含关系，即存在丢失更新问题时，其他三种问题都会存在：
- 丢失更新
- 脏读
- 不可重复读
- 幻读

### **3.3.1 第一级封锁协议**

定义：事务会对**删改操作的数据加上X锁**，但不会对查操作的数据加上S锁

解决问题：丢失更新

解决思路：在同一个时刻只有一个事务独占锁，事务之间的操作变为串行互斥

遗留问题：不会对查操作的数据加上S锁，会产生[脏读](https://blog.csdn.net/weixin_44939424/article/details/103248097)问题，即不同事务之间可以读取到相互之间操作的中间值

隔离级别：对应Read Uncommitted

### **3.3.2 第二级封锁协议**

定义：在一级封锁协议基础上，对查操作的数据加上S锁，并在**查询结束后即可释放S锁**

解决问题：丢失更新 + 脏读

解决思路：不同事务间的读、写操作互斥，会进入阻塞，这也意味着只有当**事务提交**时（独占锁释放），才会读取到数据

遗留问题：会读到其他事务提交后的值，会产生不可重复读问题，即在同事务内对相同数据的查询结果不同

隔离级别：对应Read Committed

### **3.3.3 第三级封锁协议**

定义：在一级封锁协议基础上，对查操作的数据加上S锁，**直到事务结束才释放**

解决问题：丢失更新 + 脏读 + 不可重复读

解决思路：与二级封锁协议一致，释放的时机为事务结束时释放，保证在整个事务过程中数据都不会被其他事务修改

遗留问题：仍无法解决幻读问题，因为锁的是已有数据，插入新数据则无能为力

隔离级别：对应Repeatabl Read

# **4. Mysql锁机制特性**

在3.3中介绍了广义上的三级封锁协议，Mysql在解决脏读、不可重复读和幻读时并没有严格遵循三级封锁协议，而是在二级封锁协议上加入其特性，以支持不同的隔离级别

## **4.1 MVCC**

## **4.2 间隙锁（GAP_LOCK / NEXT_KEY_LOCK）**

## **4.3 特性运用**

# 参考
- [MySQL的MVCC及实现原理](https://blog.csdn.net/SnailMann/article/details/94724197)
- [Mysql中的MVCC](https://blog.csdn.net/chen77716/article/details/6742128)

- [2PL](https://blog.csdn.net/aigoogle/article/details/25804285?locationNum=6&fps=1)
- [严格二段锁协议实现](https://blog.csdn.net/qq_37904988/article/details/105116789)

# 重点参考
- [锁机制总结](https://blog.csdn.net/Ha1f_Awake/article/details/84994697)
- [锁机制分类](https://www.hollischuang.com/archives/909)
- [MySQL中的行级锁,表级锁,页级锁](https://www.hollischuang.com/archives/914)
- [MySQL中的共享锁与排他锁](https://www.hollischuang.com/archives/923)