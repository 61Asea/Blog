# Mysql（五）：单机/集群一致性

在学习了日志系统之后，感受到了binlog的宕机恢复的重要性，这也衍生出对Mysql单机一致/Mysql主从一致/Redis和Mysql一致性的一系列疑问，在这里先解决掉上述的前两个问题

> [Mysql（四）：运作机制](https://asea-cch.life/achrives/)

binlog是Mysql实现数据一致性的重要机制，其基本核心作用是：**复制和备份**

# **1. 单机一致**

取决于redo和binlog对数据落地策略

## **1.1 最强安全性的策略**

```sql
set global variable innodb_flush_log_at_trx_commit = 1;

set global variable sync_binlog = 1;
```

redo：每次事务提交时，都会提交到os buffer中，并调用fsync()刷盘

binlog：每次事务提交时，都会将binlog_cache中的数据强制写入到磁盘中

## **1.2 兼顾性能的安全性策略**

```sql
set global variable innodb_flush_log_at_trx_commit = 2;

set global variable innodb_flush_log_at_timeout = 1;

set global variable sync_binlog = 1;
```

redo：每次事务提交时，提交到os buffer中，异步线程会在每秒调用一次fsync()进行刷盘（可以极大提升性能，但是会系统宕机时丢失1s的数据）

binlog：如1.1策略

> 单机的容错性极低，如果发生硬件/断电等不可抗力因素，单点将面临数据丢失以及服务完全不可用的问题，所以生产模式不可能为单实例

## **1.3 单机crash recovery**

数据在单机宕机恢复后是否正确，可以转化为问题：**宕机前未完成的事务，以什么作为准则进行提交/回滚**

    以binlog和redolog是否达成一致作为准则，如果一致，则提交，否则回滚

### **如何判断binlog和redolog达成一致**

> [缓冲区和日志]()一文中，有介绍事务2pc提交，会先写prepare状态到redo log中，再写binlog

在第一步写redolog 时，会将为其记录一个`XID`，它全局唯一标识事务，**会在后续写binlog时也记录在binlog中**

结论：只要binlog结束位置的XID和redolog记录的XID是一致的，则认为binlog和redolog在逻辑上是一致的，宕机恢复后就会进行提交，否则回滚

    2pc提交设计初衷，是为了分布式事务，在第二节将着重讲解以上单机crash recovery对于主从架构的意义

![binlog_redo和半同步复制](https://asea-cch.life/upload/2021/07/binlog_redo%E5%92%8C%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6-42cc5a27401240359fb76767c60e6d04.jpg)

# **2. 集群一致（主从复制）**

（Mysql集群通常指代Mysql的主从复制架构，**主服务器负责写，从服务器负责读**，即读写分离。下面默认以**一主二从**的视角进行总结）

通常使用主从复制来解决单点故障的问题，其通过binlog机制将主库的逻辑变更同步到从库

> 只要涉及到分布式系统设计，必须就要权衡CAP，一般系统都遵循：高可用，最终一致

根据不同系统对数据的一致性要求，Mysql主从复制策略可分为：
- 异步复制
- 半同步复制
- 全同步复制

## **2.1 复制过程**

![主从复制](https://asea-cch.life/upload/2021/07/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-cfb3b7b0dded4471a60f4436a9e2dbfb.webp)

先介绍在复制过程的三种线程:

- binlog dump thread（master）：用于通知slave节点，当master数据有变动时通知，**有多少个slave就有多少个binlog dump线程**
- I/O thread（slave）：用于接收master推送的binlog内容，并写入到本地的**relay-log(中继日志)**
- SQL thread（slave）：读取relay-log，根据relay-log的内容同步从库数据

大致流程如下：

1. slave节点连接master节点，对于master而言，有多少slave就创建多少个binlog dump thread

2. Master节点进行update/delete/insert操作时，写入到binlog中，通过binlog dump thread通知所有slave，并推送给slave

3. slave的I/O thread接收binlog内容，写入到relay-log中

4. slave的SQL thread读取relay-log的写入内容，同步从库

### **Mysql5.6之后的多线程复制技术**

按照上述的复制过程，线程模型如下：
- master：通过队列管理，多个线程事务操作会被leader线程依次执行，写入binlog
- slave：单I/O线程和单SQL线程，**无法并发应用中继日志**

所以在业务大的情况下很容易造成**主从延时**

多线程复制技术，

## **2.2 异步复制**

> 异步复制是Mysql的默认复制机制

策略：master不需要等待slave回应就可以提交事务

好处：**完全读写分离**，写操作不会因为slave回应而增加耗时

完整性：依赖于主库binlog的完整性（如果master宕机但binlog不丢失，还可以手工同步到从库上）

缺点：**master不保证事务变化的binlog数据会传输并应用到任何从库**。master的binlog如果丢失，则可能在master上提交过的事务没有传到slave中，此时重新选举出的master会丢失这部分数据，导致数据不一致。

## **2.3 半同步复制**

策略：master需要等待**至少一个slave**接收binlog并写入relaylog，才可以提交事务

好处：较大程度地保证了数据一致性

缺点：提升了写操作耗时

可以通过配置接收从节点ack的时机，时机点有两个，都在binlog刷盘过程的阶段中：

> []()

### **2.3.1 WAIT_AFTER_SYNC**


### **2.3.2 WAIT_AFTER_COMMIT**

## **2.4 全同步复制**

# 参考
- [Mysql主从模式的数据一致性](https://www.jianshu.com/p/790a158d9eb3)
- [小白都能懂的Mysql主从复制原理（原理+实操）](https://mp.weixin.qq.com/s/7dkPnF88o64w-u6c1MXctw)

# 重点参考
- [Mysql官网WL#5223：二进制日志组提交](https://dev.mysql.com/worklog/task/?id=5223)
- [MySQL主从复制面临的问题](https://sqlpy.com/blogs-old/books/1/chapters/7/articles/107)
- [聊聊MySQL主从复制的几种复制方式](https://baijiahao.baidu.com/s?id=1675053615227589077&wfr=spider&for=pc)
- [mysql 5.6 binlog组提交实现原理](http://blog.itpub.net/15480802/viewspace-1411356/)
- [mysql主从之多线程复制](https://www.cnblogs.com/zyxnhr/p/11154700.html)
- [InnoDB二阶段日志提交机制](https://www.linuxidc.com/Linux/2018-01/150186.htm)

# 深度好文
- [异步复制](https://www.cnblogs.com/kevingrace/p/6256603.html)
- [半同步复制](https://www.cnblogs.com/kevingrace/p/10228694.html)
- [基于GTID复制](https://www.cnblogs.com/kevingrace/p/5569753.html)
- [基于组提交和并行复制 (解决同步延迟)](https://www.cnblogs.com/kevingrace/p/5569652.html)
- [组复制MGR](https://www.cnblogs.com/kevingrace/p/10260685.html)