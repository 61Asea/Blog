## **JVM**
### **1. Java内存区域 (运行时数据区域)**
Java内存区域和内存模型JMM是不同的东西
- **内存区域是指Jvm运行时将数据分区域存储，强调对内存的划分** 
- JMM定义了JVM在计算机内存的工作方式，与并发编程更相关

tip： 
#### 操作系统底层线程模型：
- 1:1模型

    使用内核线程实现，内核线程是直接由内核Kernel支持的线程，程序一般不会直接使用内核线程，而是用内核线程的一种轻量级线程接口（LWP）
    
    轻量级线程也就是**意义上的java多线程**，每个轻量级线程对应一个内核线程支持，俗称1:1

    内核线程保证了系统对线程的**可见性**，如果一个LWP线程阻塞了，也不会影响到同一进程上的另一LWP线程，进程不会因此阻塞

    缺点：每次切换都要从用户态->内核态->用户态

- n：1模型

    用户线程完全建立在用户空间的线程库上，可以简单理解为绑定在一个内核线程上，这种线程不需要切换内核态

    缺点：若一个用户态线程阻塞，整个进程阻塞。即线程操作由用户解决，阻塞处理十分困难，十分复杂

- m：n模型

#### Java的线程调度模型：抢占式调度
    每个线程都由系统分配执行时间，线程切换不依赖线程自己决定，若希望系统分配更多时间，则通过设置线程优先级来使得某些线程能在同一时间段内获得更多的操作时间

    总共有十个优先级Thread.MIN_PRIORITY至Thread.MAX_PRIORITY

#### **1.1 程序计数器（线程私有）**

是当前线程所执行的**字节码的行号指示器**，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令

它是**程序控制流的指示器，分支（if, switch/循环(iterator)/异常处理(try-catch)/线程恢复(yield,wait)等操作**等基础操作都需要计数器完成

由于程序在多线程下切换，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，**线程都需要有一个独立的计数器，各个线程之间的计数器互不影响**

如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；

#### **1.2 java虚拟机栈（线程私有）**
##### **栈帧**
- **局部变量表**

    堆栈分析中，栈分析中最多情况下的内容

    局部变量表存放了编译器可知的：
    - Java虚拟机基本数据类型（boolean/int/float/long/double）
    - 对象引用
    - returnAddress

    数据类型在局部变量中会以局部变量槽Slot来表示，double和long一般占用两个变量槽，这样在编译期通过后，局部变量表的大小是完全确定的，在方法运行期间也不会再改变局部变量表大小
    
    变量槽不固定具体比特大小，具体大小由对应虚拟机实现。

- 操作栈

    JVM的执行引擎是基于栈的操作引擎，其中的栈指的就是操作栈

- 动态连接

    每个栈帧包含一个在常量池对该方法的引用，支持方法调用过程的动态链接

- 方法出口

    相当于弹出当前栈帧，退出的方式有三种：
    1. 返回值压入上层调用的栈帧（在某个方法调用另一个方法）
    2. 异常信息抛给能处理的栈帧（捕获异常或继续向外抛出异常）
    3. PC计数器指向方法调用后的下一条指令（继续往下执行）

Java虚拟机栈生命周期：与线程相同

描述的是Java方法执行时的数据结构：每个方法在执行时都会创建一个栈帧（Stack Frame）

只有位于栈顶的栈帧才是有效的，也称为当前栈帧，其对应的方法也称为当前方法，在执行引擎时，所有指令只对栈顶执行

**每个Java方法从调用到执行完毕，即对应一个栈帧从虚拟机栈中入栈到出栈的过程**

    在活动过程中，只有处于栈顶的栈帧才是有效的，成为当前栈帧，正在执行的方法称为当前方法，所有指令都只对当前栈帧做操作

    该模块区域可以认为是CPU高速缓存/寄存器（操作数栈）所使用的工作内存（局部变量表），但是不可能一概而论去与JMM进行对应
    
    因为JMM是为了解决共享数据（简单认为是堆里的对象实例部分数据）读写一致性问题的模型

    若以以上模型，JMM对应：主内存（堆）读取数据，加载到线程的工作内存中（局部变量表），内核级线程对应LWP，基于栈执行栈顶（操作数栈）得到结果，刷新工作内存，再通过工作内存刷回主内存，读写不一致也就是在此时出现

#### **1.3 本地方法栈**

与Vm Stack类似，用于Native方法调用

**栈深度溢出StackOverflowError， 栈扩展溢出OutOfMemoryError**

    延伸i++和++i的并发问题，以JMM和VM内存区域诠释：
    
    1. i++，先从主存中（堆）中获取i的数值，加载到工作内存（虚拟机栈的局部变量表）中，当线程操作时，会读取i的值压入操作栈，然后再对局部变量表的i值+1，这样在操作栈取出使用的就是自增前的值

    2. ++i反之

    并发问题：
        这个操作其实分为3步，不是一个原子操作：i从内存中取出压入栈，内存i值自增1，将操作栈（寄存器）取出使用。
        
        其中第二步，会将工作内存的值刷回到主存中，如果没有同步操作，则会出现并发问题

        即使是对i使用了volatile，也无法确保其安全性。因为就算每次工作内存都能获取最新的值，但是在往回写入主存时，仍没解决并发执行导致值覆盖的情况。

#### **1.4 Java堆**

Jvm管理内存最大的一块区域，常出现内存泄漏的地方，所有线程共享，对应JMM的主存