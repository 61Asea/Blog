### **垃圾收集与内存分配**

- 哪些内存需要回收？
- 什么时候回收？
- 怎么回收？

虚拟机栈/计数器/本地方法栈，生命周期与线程重合，这几个区域的内存**分配**（在类结构确定下来，即编译期，便已知栈帧大小）和**回收**（线程死亡）都具备确定性

堆和方法区具有动态性质，无法确定大小，一个接口的多个实现类所需要的内存大小可能不同，执行的方法需要的内存也不一样

#### **1. 对象”死亡“**

指的是对象不可能再被任何途径使用（GC Roots无法到达）

#### **1.1 引用计数法**

在对象中占用额外的内存空间，添加一个引用计数器，每当一个地方引用它，则计数器+1；当引用失效时，计数器-1；

**任何时刻计数器为零的对象就是不可能再被使用的**

- 优点：

    判定效率极高，原理简单

- 问题：

    需要额外考虑很多例外情况，配合大量的额外处理，很难解决**对象之间的相互引用问题**

#### **1.2 可达性分析（重点）**

#### **1.2.1 可达性分析原理**

通过一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”

如果某个对象到GC Roots间没有任何引用链相连，或者用图论而言，**GcRoots到这个节点不可达时**，则证明该对象不可能再被使用

    tracing GC的本质是通过找出所有活对象来把其余空间认定为“无用”，而不是找出所有死掉的对象并回收它们占用的空间

#### **GC Roots**

GC Roots，或者说tracing GC的根节点，就是**一组必须活跃的引用**（必须要能完整枚举出所有GC Roots，否则就可能漏扫描活跃的对象，导致活跃对象错误回收）

固定可作为GC Roots的对象包括以下几种：
- 在**虚拟机栈（局部变量表）引用的对象**，譬如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等

    **所有Java线程当前活跃栈帧里指向GC堆里的对象的引用，即当前所有正在被调用的方法的引用类型的参数/局部变量/临时值**

- 在**方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量**
- 在**方法区中常量引用的对象，譬如字符串常量池的引用**
- 在本地方法栈中JNI（Native方法）引用的对象
- Java虚拟机内部的引用，如基本数据类型对于的Class对象，一些常驻的异常对象，**系统类加载器**
- **所有被同步锁持有的对象**
- 反映Java虚拟机内部情况的JMXBean/JVMTI中注册的回调、本地代码缓存等

除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以又其他对象临时性地加入，共同构成完整的GC Roots集合：

    基于分代式GC的部分收集做法，在执行部分收集时，从GC堆非收集部分指向收集部分的引用（即非收集部分对象有收集部分对象的引用），则该引用也必须作为GC Roots的一部分

#### **1.2.2 分析回收**

即使**在可达性分析中被判定为不可达对象，也不会立即回收**，要真正宣告一个对象的死亡并回收，至少要经历两次标记过程：

1）**进行可达性分析后，发现没有GC Roots与之相连，会被第一次标记**，标记后执行一次筛选

2）在F-Queue中第二次小规模标记，由vm自动建立的Finalizer去执行队列中对象的finalize()方法

在第一次标记过程后，会立即进行一次筛选，假如对象**没有覆盖finalize()方法**，或者**finalize()方法已经被虚拟机调用**过，那么vm会将这两种情况都视为没有必要执行finalize

在上述筛选后，如果认定**有必要执行finalize()方法**，则对象会被放置于**F-Queue队列**中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer去异步执行finalize()方法（同步如果失败，则阻塞住产生巨大的危险）

如果对象在第一次标记后的筛选，认为没有必要执行finalize方法，则直接回收；有必要执行则加入到F-Queue队列中

在F-Queue，对对象进行第二次标记，**如果被重新引用到引用链上，那么就被移除“即将回收”集合，对象存活；反之，将被回收**

**=》证明：finalize()方法只会被vm自动执行一次**

    可达性分析，无GC Roots可达 -》 第一次标记

    第一次标记 =》筛选，有必要执行 =》进入F-Queue中等待VMFinalizer
                     没必要执行 =》直接回收

    第二次标记 =》调用finalize()方法 =》重新引用赋值，进入GC Roots引用链，复活
                                  =》死亡

    因为finalize()方法只会被vm自动执行一次
    复活 =》 不可达分析又满足 =》第一次标记 =》必定没必要执行 =》直接回收


#### **1.3 引用**

- 强引用 Strongly Reference

    最传统的“引用”定义，包括：**引用赋值**，只要强引用关系仍存在，则不会被回收

- 软引用 Soft Reference

    还有用，但非必须的对象。被软引用关联着的对象，**在系统将要发生内存溢出前，会将这些对象列入回收范围内进行第二次回收**，如果回收后还没有足够的内存，才会抛出OOM

- 弱引用 Weak Reference

    非必须对象，**只能生存到下一次垃圾收集**发生为止（无论内存是否足够）

- 虚引用 Phantom Reference

    “虚灵引用”/“幻影引用”，该引用的唯一目的只是为了能在这个对象被回收时收到一个系统通知

**以上引用强度依次逐渐减弱**

#### **1.4 回收方法区**

方法区的垃圾收集性价比很低，在新生代中常规收集就能够回收70%和99%的内存空间，方法区**远远不足**

主要回收两个部分：
- 废弃常量

    以字符串为例，在方法区中常量池上，有一个字符串“java”， 但当前系统上没有字符串对象的引用常量池上的“java”，且vm上也没有其他地方引用这个常量，则会被清除出常量池

- 不再使用的类型

    - 该类的所有实例已被回收
    - 加载该类的类加载器已经被回收
    - 该类对于的java.class.Class对象没有在任何地方被引用

满足上述条件，则VM被允许回收，而不是像GC堆一样，没有了引用就必然会回收

关于是否要对类型进行回收，提供了-Xniclassgc等参数进行控制

#### **2. 垃圾收集算法**

重点介绍**分代收集理论**和几种算法思想及其发展过程

Java的垃圾收集算法，是基于追踪式垃圾收集，来判定对象消亡。而通过分代收集，在不同类型的GC收集器上，本质上是：

1. 缩短**同步GC**的每次GC的时间（假设每次都是Full-Gc，耗时将过长，应用将处于长时间的不可用）

2. 提高**并发安全的GC**的内存分配率，**尽快回收出越多空间**，应用内存分配速率（allocation rate）可以得到巨大的提升（并发安全GC不存在同步GC的停止问题）

        并发GC的根本：
        
        应用一边在分配，GC一边在收集，如果GC收集的速度能跟得上应用分配的速度，那就一切都很完美；一旦GC开始跟不上了，垃圾就会渐渐堆积起来，最终到可用空间彻底耗尽的时候，应用的分配请求就只能暂时等一等了，等GC追赶上来
        
        所以，对于一个并发GC来说，这也更需要使用分代收集，尽快回收出越多空间，就能够应付越高的应用内存分配速率，从而更好地保持GC以完美的并发模式工作
        
从如何**判定对象消亡的角度**，垃圾收集算法可划分为：
- 引用技术式垃圾收集

    Reference Counting GC，**直接垃圾收集**

- 追踪式垃圾收集（HotSpot Jvm）

    Tracing GC，也是上述的GC Roots根节点向下引用链搜索

    Tracing GC的本质是通过找出所有活对象来把其余空间认定为“无用”，而不是找出所有死掉的对象并回收它们占用的空间，也称为**间接对象收集**

#### **2.1 分代收集理论**

    两个分代的三大基本假设：
    1）弱分代假说 (weak generational hypothesis)：大部分对象的生命期很短，而没有die young的对象则很可能会存活很长时间（朝生夕灭）

    2）强分代假说 (strong generational hypothesis)：熬过越多次垃圾收集过程的对象就越难以消亡

    3）跨代引用假说 (intergenerational reference hypothesis)：跨代引用相对于同代引用来说仅占极少数

F大：

基于以上的假设，频繁收集young gen，则大部分垃圾都能在新生代中被收集掉，由于**young gen的大小配置通常只占整个GC堆的很小部分**，而且较高死亡率，这也让它很**适合使用copying算法进行收集**，这样不但降低单次GC的时间长度，还可以提高GC的工作效率

周志明：

收集器应该将GC堆划分出不同的区域，将回收对象依据其年龄（熬过垃圾收集过程的次数，也就是上述的GC计数器值）分配到不同的区域之中存储

    第一假说理解（young gen来由）：

    因为大部分新创建的对象都是朝生夕灭的，意味着如果只对新创建的对象进行回收的话，回收率高，能回收到大量的空间
    
    每次新生代GC时，可以只关注：
    如何保留少量的存活对象（Survior，再逐步晋升到老年代），而不是去标记哪些大量将要被回收的对象（因为这些对象被标记后，大概率都会被回收）

    第二代假说理解（old gen来由）：

    剩下的就是难以消亡的对象，把它们集中在一块，vm就能以较低的频率回收这个区域

这样就同时兼顾了垃圾收集的时间开销和内存空间的有效利用

在GC堆的不同分代下，GC可以每次**只回收某一个或某些部分的区域**，即部分收集：
- Minor GC
- Major GC
- Full GC

针对以上不同的区域，来**安排与之存储对象消亡特征匹配的**，具有针对性的垃圾收集算法：
- 标记-复制算法
- 标记-清除算法
- 标记-整理算法

#### 问题：对象并不少孤立的，对象之间存在跨代引用

    第三假说的理解：

    存在互相引用关系的对象，是应该倾向于同时生成或同时消亡的

    新生代对象刚分配，对应引用的对象可能也是同期一起生成的，它们将会一直处于同个分代中

    新生代对象刚分配，就跨代引用，由于引用的老年代对象难以消亡，该引用会使得新生代对象在收集时难以消亡，新生代对象进而也很容易晋升到老年代中

基于上述问题，GC没有必要去扫描整个老年代，也不必专门去记录每个对象是否存在以及存在哪些跨代引用，只要在新生代上建立一个全局数据结构（**记忆集**）

#### 记忆集

该结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用

在对象改变引用关系/赋值引用时，会修改记忆集的数据（增加一些运行时的开销）

此后的Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描