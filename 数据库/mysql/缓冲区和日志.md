# Mysql（四）：运作机制

> [Mysql（一）：innodb存储](https://asea-cch.life/achrives/innodb存储)

> [Mysql（二）：索引](https://asea-cch.life/achrives/索引)

> [Mysql（三）：锁机制](https://asea-cch.life/achrives/锁机制)

上两篇文章主要介绍了innodb的外存存储和索引机制，我们深刻地感受到I/O操作对于系统的性能至关重要，Mysql使用B+树组织数据，并贯彻系统局部性原理，最小操作单位为一个页，以尽可能地减少对库操作时I/O的次数

那么在软件层面上，Mysql运作机制又是什么？

![逻辑架构](https://asea-cch.life/upload/2021/06/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84-4702c42811ee452fa842577bf56fd56a.png)

Buffer Pool对应图中的**查询缓存**，处于内存区域，是数据库对磁盘读写进行缓存加速的机制。它使得操作不会立即反馈到磁盘上，而是先操作缓存，极大程度提高数据的访问速度

![缓冲池和日志文件结构](https://asea-cch.life/upload/2021/06/%E7%BC%93%E5%86%B2%E6%B1%A0%E5%92%8C%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-b4d927e2591d465197630da28169e012.jpg)

上图中与磁盘文件平行的，就是数据库的日志系统，它是数据库的重要保护机制，数据库事务通过日志系统与锁机制共同实现原子性、持久性和隔离性，进而保证了业务数据的一致性

# **1. Buffer Pool**

![bufferPool结构](https://asea-cch.life/upload/2021/06/bufferPool%E7%BB%93%E6%9E%84-ab9d2f8d4e194de388ef16c3df61eaf7.jpg)

## **1.1 缓存页和描述信息**

## **1.2 **

# **2. 日志系统**

binlog是**MYSQL数据库层面**的日志，也就是我们常说的二进制日志，不管是什么存储引擎，对数据库进行修改都会产生二进制日志



undo.log/redo.log是**InnoDB存储引擎**的日志，即只有使用了innodb引擎才会产生

事务的隔离性由锁策略决定（undo日志提供MVCC作为辅助），原子性和持久性则由undo/redo日志完成，他们共同构筑了事务的一致性

## **2.1 redo.log**

别名：重做日志

作用：提供事务**持久性**

组成部分：
- 在内存中的日志缓冲（redo log buffer），具有易失性
- 在磁盘上的重做日志文件（redo log file），具有持久性

### **2.1.1 日志结构**

### **日志组（log group）**

```sql
# 输出日志系统的信息
show global variables like 'innodb_log%';
```

![redo日志组和日志文件大小](https://asea-cch.life/upload/2021/06/redo%E6%97%A5%E5%BF%97%E7%BB%84%E5%92%8C%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F-1b768fb56f5340b5b6b15adb35f0ecbd.png)

    上图表示redo日志组由4个log_file组成，每个log_file的大小为268435456字节（256MB），所以该日志组的整体大小为1GB

redo日志组是固定大小的，以**环状**的方式对组内的文件进行链接，在innodb将log buffer中的redo log block刷到这些log file中时，会以追加写入的方式**循环轮询写入**

在日志组第一个log_file（ib_logfile0）的尾部进行追写，直到满了后向下一个log_file（ib_logfile1）写。当最后一个log_file也写满了，则会清空一部分第一个log_file，以此类推，继续**循环轮询写入**

![logfile文件](https://asea-cch.life/upload/2021/06/logfile%E6%96%87%E4%BB%B6-fa1b23c41e4b4b98befa7a253120d9b1.png)

#### **日志块（log black）**

redo log buffer、os buffer和磁盘redo log文件都是以**日志块为单位**进行存储，与磁盘扇区大小一致，每个块占512字节，这样可以保证**写日志扇区的操作是原子**


#### **日志格式**

### **2.1.2 实现机制**

`Writing Ahead Logging`：简称WAL，即先写日志，再写数据

`Force Log At Commit`：在事务提交时，**必须先**将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化，以保证断电后的灾难恢复

### **2.1.3 刷盘机制**

上述两种机制其实代指同一种，核心思想都是**先写日志**，从日志缓冲写入内核buffer，再从os buffer写入到真实磁盘log文件

![redo和undo日志的写入](https://asea-cch.life/upload/2021/06/redo%E5%92%8Cundo%E6%97%A5%E5%BF%97%E7%9A%84%E5%86%99%E5%85%A5-8aa7859c7c5d476fa6f5f56773c08155.png)

> [深度好文，讲解了日志写盘的机制与流程](https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html#auto_id_2)

可以看到os buffer作为写操作的缓冲区，这是因为open磁盘的日志文件时，**没有使用O_DIRECT标志位**，这意味着不会IO直写到底层存储设备。而是等待缓冲区到了一定容量后，或者显式地调用fsync()方法，才会冲刷缓冲区数据到磁盘中，这可以**减少I/O写盘次数**

    比如写abcde，如果开启了O_DIRECT，需要5次调用，而如果没有开启标志位，则只发起一次系统调用


## **2.2 undo.log**

确保事务的原子性，保存了事务发生前的多个版本，可以用于回滚

更被作为MVCC（多并发控制版本）的实现支持，以实现非锁定的一致读

## **2.3 binlog**

# 参考
- [理解Mysql中的Buffer pool](https://www.cnblogs.com/wxlevel/p/12995324.html)
- [详解MySQL中的缓冲池](https://blog.csdn.net/weixin_42305622/article/details/113424622)
- [Mysql Buffer Pool](https://blog.csdn.net/qq_27347991/article/details/81052728)

- [MySQL日志系统：redo log、binlog、undo log 区别与作用](https://blog.csdn.net/u010002184/article/details/88526708)

# 重点参考
- [详细分析MySQL事务日志(redo log和undo log)](https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html#auto_id_2)
- [MySQL中常见的几种日志](https://zhuanlan.zhihu.com/p/150105821?from_voters_page=true)