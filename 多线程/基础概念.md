# 基础概念

## 1. 进程与线程

进程：操作系统分配资源和调度的基本单位，是代码在**数据集合上的一次运行活动**

线程：CPU资源分配的基本单位（最终占用CPU资源的是线程）

线程是进程中的一个实体，不能独立存在，是进程的一个执行路径。进程至少有一个线程，进程中的线程共享进程的资源

## 2. 线程的生命周期

![线程状态图](https://img-blog.csdnimg.cn/20190804232630162.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pkc2pseng=,size_16,color_FFFFFF,t_70)

![线程状态图，wait返回synchronized同步块](https://static.oschina.net/uploads/space/2018/0308/124802_AB5e_2885163.png)

### **2.1 状态**

```java
    /**
    * Thread.State枚举
    * @since 1.5
    * @see #getState
    */
    public enum State {
        NEW, // 创建状态
        RUNNABLE, // 运行状态
        BLOCKED, // 阻塞状态
        WAITING, // 无限期等待状态
        TIMED_WAITING, // 计时等待状态
        TERMINATED; // 终止状态
    }
```

1. New 创建状态

    new Thread()，线程对象被创建，但还未执行start()方法

2. Runnable 运行状态

    - READY：就绪状态，该状态下线程已获得除cpu资源外的其他资源（包括vm分配的虚拟机栈、本地方法栈和程序计数器）

        - 调用线程start()方法，进入就绪状态
        - **从锁池（Blocked）获得对象锁的线程，进入就绪状态**
        - 当前线程时间片用完了，调用当前线程的yield()方法，进入就绪状态
        - 当前线程sleep()方法结束
        - 当前线程对其他线程join()结束

    - RUNNING：执行状态，线程开始获得OS分配的cpu资源，执行工作

        根据OS调度，从就绪状态中的线程中取出一个进行执行

    调用new Thread().start()方法，首先进入READY就绪状态等待OS分配cpu时间片，在获得cpu资源后进入RUNNING状态

3. Blocked 阻塞状态

    线程在该状态下会等待获取监视器锁，以进入/重新进入synchronized块

    若线程在Runnable状态下获取监视器锁失败，会直接转换到Blocked状态

    **若线程在waiting或timed_waiting（调用obj.wait()方法），重新进入synchronized，会直接转换到Blocked状态**

4. Timed_waiting 计时等待状态

    在一定时间后被系统唤醒，一般是线程调用带超时参数的方法进入，如：Thread.sleep(long time) / thread.join(long time) / Object.wait(long time)

    进入Timed_waiting情况:
    - 当前线程调用监视器锁对象的wait(long time)方法
    - 当前线程调用线程静态方法，Thread.sleep(long time)
    - 当前线程调用其他线程对象的join(long time)方法

    退出Timed_waiting情况：
    - 当前获得监视器锁的线程执行notify/notifyAll()，唤醒后被加入到锁池中，进入blocked状态
    **- 超时时间到达，不管是调用Thread.sleep/thread.join方法，还是调用lockObj.wait()的线程，都会返回ready状态**

5. Waiting 无限期等待状态

    不会被分配cpu资源，需要显式唤醒(当前占用锁的线程使用notify/notifyAll()进行唤醒)，一般由持有锁的线程调用锁对象的wait()

    进入Waiting情况:
    
    **- 当前线程调用监视器锁对象的wait()方法**
    - 当前线程调用其他线程对象的join()方法（**本质上会进入其他线程对象的同步块，调用线程对象的wait()方法**），等待该线程对象任务结束

    退出waiting情况：

    被notify/notifyAll()唤醒后被加入到锁池中，进入blocked状态

6. Terminated 终止状态

    已终止状态，线程正常运行完毕或捕获异常中止

### **2.2 线程优先级**

```java
    /**
    * The minimum priority that a thread can have.
    */
    public final static int MIN_PRIORITY = 1;

    /**
    * The default priority that is assigned to a thread.
    */
    public final static int NORM_PRIORITY = 5;

    /**
    * The maximum priority that a thread can have.
    */
    public final static int MAX_PRIORITY = 10;

    private void init(...) {
        Thread parent = currentThread();
        this.priority = parent.getPriority();
        setPriority(priority);
    }
```

默认主线程的优先级为NORM_PRIORITY，在主线程创建的子线程优先级都为NORM_PRIORITY

### **2.3 锁池与等待队列**

每个对象都可以承担锁的功能，所以Java虚拟机会**为每个对象维护两个队列**，一个叫Entry Set(入口集)，另外一个叫Wait Set（等待集）

Entry Set（入口集/锁池/同步队列/monitor池）：存放想争夺对象锁的线程，池中的线程处于Blocked状态

Wait Set（等待集/等待队列/等待池）：存放执行了obj.wait()的线程，池中的线程处于Waiting状态

等待池中的线程被notify()或者notifyAll()方法唤醒进入到锁池，进入Blocked状态。最后竞争到了锁并且进入了Runnable状态的话，会从wait现场恢复，执行wait()方法之后的代码

    即被notify/notifyAll的线程（肯定处于obj的等待集），直接从Waiting =》 Blocked

![等待队列和同步队列](https://img-blog.csdnimg.cn/20190804232832471.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pkc2pseng=,size_16,color_FFFFFF,t_70)

```java
    /**
    * 状态转换demo
    * 异步线程1刚初始化: NEW
    * 异步线程1获得cpu资源，进入锁: RUNNABLE
    * 异步线程1主动wait: TIMED_WAITING
    * 异步线程2状态：NEW
    * 异步线程2状态：BLOCKED
    * 异步线程1调用wait之后: RUNNABLE
    * 主线程进入同步块
    * 异步线程2获得cpu资源，进入锁: RUNNABLE
    * 异步线程2调用wait之后: RUNNABLE
    * 执行使用的所有时间: 8.501
    */
    public class ThreadDemo implements Callable<Object> {
        public final static Object lock = new Object();

        public static FutureTask<Object> future = new FutureTask<>(new ThreadDemo());

        public static Thread thread = new Thread(future, "异步线程1");

        public static FutureTask<Object> future1 = new FutureTask<>(new ThreadDemo());

        public static Thread thread1 = new Thread(future1, "异步线程2");

        @Override
        public Object call() throws Exception {
            synchronized (lock) {
                Thread thread = Thread.currentThread();
                System.out.println(thread.getName() + "获得cpu资源，进入锁: " + getState(thread));
    //            lock.wait(10 * 1000);
                Thread.sleep(4 * 1000);
                System.out.println(thread.getName() + "调用wait之后: " + getState(thread));
                return null;
            }
        }

        private Thread.State getState(Thread thread) {
            return thread.getState();
        }

        public static void main(String[] args) throws Exception {
            long startTime = System.currentTimeMillis();
            System.out.println(ThreadDemo.thread.getName() + "刚初始化: " + ThreadDemo.thread.getState());
            ThreadDemo.thread.start();

            Thread.sleep(500);
            System.out.println(ThreadDemo.thread.getName() + "主动wait: " + ThreadDemo.thread.getState());

            System.out.println("异步线程2状态：" + ThreadDemo.thread1.getState());
            ThreadDemo.thread1.setPriority(Thread.MAX_PRIORITY);
            ThreadDemo.thread1.start();
            Thread.sleep(2 * 1000);
            System.out.println("异步线程2状态：" + ThreadDemo.thread1.getState());

            synchronized (ThreadDemo.lock) {
                System.out.println("主线程进入同步块");
                ThreadDemo.lock.notifyAll();
    //            System.out.println("异步线程1被主线程唤醒: " + ThreadDemo.thread.getState());

                Thread.sleep(500); // 持有锁不释放，异步线程会一直处于获取锁的状态
            }

            ThreadDemo.thread.join();
    //        System.out.println("完成任务后状态: " + ThreadDemo.thread.getState());

            ThreadDemo.thread1.join();
            System.out.println("执行使用的所有时间: " + ((System.currentTimeMillis() - startTime) * 0.001));
    }
```

### 2.4 **线程/监视器锁相关的方法**

```java
    Thread t = new Thread();

    Thread.sleep(10 * 1000);
    
    t.start();
    t.join();

    synchronized(obj) {
        obj.wait();
        obj.notify() / obj.notifyAll();
    }
```

#### 2.4.1 Thread.sleep(long time)

线程类的静态方法，使得当前执行的线程休眠time个时间。超时时间到了，则线程进入就绪状态

线程状态：running =》 timed_waiting =》 ready

#### 2.4.2 t.join() / t.join(long time)

```java
public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }
```

线程对象方法，使得当前执行的线程阻塞（waiting/timed_waiting），等待t线程消亡，当前线程才会继续执行

主线程调用t.join()抢到监视器t, 且t未消亡: running => waiting(t.wait()，需要t线程完成时唤醒) => blocked(主线程唤醒) => ready => running

主线程调用t.join()未抢到监视器t，且t未消亡: running => blocked(进入锁池) => waiting => blocked(主线程唤醒) => ready => running

主线程调用t.join(long time)抢到监视器t，且t未消亡：

running => timed_waiting => ready(wait时间到了) => 开始的running
                         => blocked(在wait时间内，t完成并唤醒)

#### 2.4.3 obj.wait() / obj.wait(long time)

当前线程调用后，将释放锁，并进入锁对象的等待集中

带参数会进入timed_waiting状态，超时会进入ready状态，显式唤醒都会使得线程重新进入blocked状态

不带参数进入waiting状态，则直接进入waiting状态，必须显式唤醒，唤醒后进入blocked状态

#### 2.4.2 obj.notify() / obj.notifyAll()

notify()会随机唤醒等待集的一个线程

notifyAll()会唤醒等待集的所有线程，被唤醒的线程全部加入到锁池中

# 参考
- [Java线程等待唤醒机制](https://blog.csdn.net/jdsjlzx/article/details/98470930)
- [为JAVA的线程设置优先级](http://www.dovov.com/java-462.html)
- **[wait()被唤醒后进入的状态](https://my.oschina.net/zjllovecode/blog/1630716)**
- [Java中的锁池和等待池](https://blog.csdn.net/qq_22498277/article/details/82184419)
- [wait()带参数的问题](http://bbs.itheima.com/thread-311354-1-1.html)
- [为什么wait通常要放在while中](https://zhuanlan.zhihu.com/p/89710060)