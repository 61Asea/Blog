## **JVM内存区域**
### **1. Java内存区域 (运行时数据区域)**
Java内存区域和内存模型JMM是不同的东西
- **内存区域是指Jvm运行时将数据分区域存储，强调对内存的划分** 
- JMM定义了JVM在计算机内存的工作方式，与并发编程更相关

tip： 
#### 操作系统底层线程模型：
- 1:1模型

    使用内核线程实现，内核线程是直接由内核Kernel支持的线程，程序一般不会直接使用内核线程，而是用内核线程的一种轻量级线程接口（LWP）
    
    轻量级线程也就是**意义上的java多线程**，每个轻量级线程对应一个内核线程支持，俗称1:1

    内核线程保证了系统对线程的**可见性**，如果一个LWP线程阻塞了，也不会影响到同一进程上的另一LWP线程，进程不会因此阻塞

    缺点：每次切换都要从用户态->内核态->用户态

- n：1模型

    用户线程完全建立在用户空间的线程库上，可以简单理解为绑定在一个内核线程上，这种线程不需要切换内核态

    缺点：若一个用户态线程阻塞，整个进程阻塞。即线程操作由用户解决，阻塞处理十分困难，十分复杂

- m：n模型

#### Java的线程调度模型：抢占式调度
    每个线程都由系统分配执行时间，线程切换不依赖线程自己决定，若希望系统分配更多时间，则通过设置线程优先级来使得某些线程能在同一时间段内获得更多的操作时间

    总共有十个优先级Thread.MIN_PRIORITY至Thread.MAX_PRIORITY

![vm内存区域](https://images2015.cnblogs.com/blog/584866/201704/584866-20170426175411428-34722603.png)

#### **1.1 程序计数器（线程私有）**

是当前线程所执行的**字节码的行号指示器**，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令

它是**程序控制流的指示器，分支（if, switch/循环(iterator)/异常处理(try-catch)/线程恢复(yield,wait)等操作**等基础操作都需要计数器完成

由于程序在多线程下切换，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，**线程都需要有一个独立的计数器，各个线程之间的计数器互不影响**

如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；

#### **1.2 java虚拟机栈（线程私有）**
##### **栈帧**
- **局部变量表**

    堆栈分析中，栈分析中最多情况下的内容

    局部变量表存放了编译器可知的：
    - Java虚拟机基本数据类型（boolean/int/float/long/double）
    - 对象引用
    - returnAddress

    数据类型在局部变量中会以局部变量槽Slot来表示，double和long一般占用两个变量槽，这样在编译期通过后，局部变量表的大小是完全确定的，在方法运行期间也不会再改变局部变量表大小
    
    变量槽不固定具体比特大小，具体大小由对应虚拟机实现。

- 操作栈

    JVM的执行引擎是基于栈的操作引擎，其中的栈指的就是操作栈

- 动态连接

    每个栈帧包含一个在常量池对该方法的引用，支持方法调用过程的动态链接

- 方法出口

    相当于弹出当前栈帧，退出的方式有三种：
    1. 返回值压入上层调用的栈帧（在某个方法调用另一个方法）
    2. 异常信息抛给能处理的栈帧（捕获异常或继续向外抛出异常）
    3. PC计数器指向方法调用后的下一条指令（继续往下执行）

Java虚拟机栈生命周期：与线程相同

描述的是Java方法执行时的数据结构：每个方法在执行时都会创建一个栈帧（Stack Frame）

只有位于栈顶的栈帧才是有效的，也称为当前栈帧，其对应的方法也称为当前方法，在执行引擎时，所有指令只对栈顶执行

**每个Java方法从调用到执行完毕，即对应一个栈帧从虚拟机栈中入栈到出栈的过程**

    在活动过程中，只有处于栈顶的栈帧才是有效的，成为当前栈帧，正在执行的方法称为当前方法，所有指令都只对当前栈帧做操作

    该模块区域可以认为是CPU高速缓存/寄存器（操作数栈）所使用的工作内存（局部变量表），但是不可能一概而论去与JMM进行对应
    
    因为JMM是为了解决共享数据（简单认为是堆里的对象实例部分数据）读写一致性问题的模型

    若以以上模型，JMM对应：主内存（堆）读取数据，加载到线程的工作内存中（局部变量表），内核级线程对应LWP，基于栈执行栈顶（操作数栈）得到结果，刷新工作内存，再通过工作内存刷回主内存，读写不一致也就是在此时出现

#### **1.3 本地方法栈**

与Vm Stack类似，用于Native方法调用

**栈深度溢出StackOverflowError， 栈扩展溢出OutOfMemoryError**

**HotSpot的栈容量无法动态扩展，在申请成功时就就已经确定，所以不会出现OOM，但如果是在申请时就失败，也会出现OOM**

    延伸i++和++i的并发问题，以JMM和VM内存区域诠释：
    
    1. i++，先从主存中（堆）中获取i的数值，加载到工作内存（虚拟机栈的局部变量表）中，当线程操作时，会读取i的值压入操作栈，然后再对局部变量表的i值+1，这样在操作栈取出使用的就是自增前的值

    2. ++i反之

    并发问题：
        这个操作其实分为3步，不是一个原子操作：i从内存中取出压入栈，内存i值自增1，将操作栈（寄存器）取出使用。
        
        其中第二步，会将工作内存的值刷回到主存中，如果没有同步操作，则会出现并发问题

        即使是对i使用了volatile，也无法确保其安全性。因为就算每次工作内存都能获取最新的值，但是在往回写入主存时，仍没解决并发执行导致值覆盖的情况。

#### **1.4 Java堆**

Jvm管理内存最大的一块区域，常出现内存泄漏的地方，所有线程共享，对应JMM的主存

**唯一目的：存放对象实例，所有的对象实例以及数组都应当在堆上分配**

是垃圾收集器管理的内存区域，由于现代垃圾收集器大部分是基于分代收集理论，所以堆中常出现：

**新生代，老年代。永久代（已去除），Eden空间，From Survior空间，To Survior空间**

**从分配内存的角度看**，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（TLAB），以提升对象分配时的效率

堆内存物理上可以不连续，但是要在逻辑上连续

#### 1.4.1 TLAB

是为了解决线程分配时的竞争问题，这一切都与new和指针碰撞有关

##### 指针碰撞
    假设JVM堆的内存区域都是规整的，堆内存被一个指针一分为二，一边为已使用区域，一边为未使用区域

    当需要创建新对象时，指针会往右移动一个size的距离，并填上新的对象
    
多个线程在分配内存时，会根据指针位置在未使用区域分配内存，这也就会出现A线程在分配内存，指针未修改完毕的同时，有B线程也同时去分配内存，出现竞争问题

#### **1.5 方法区**

方法区与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的**类型信息，常量，静态变量，JIT编译后的代码缓存**数据

难点在于JDK8之前与之后的实现：
    **JDK8之前使用永久代实现，JDK8之后使用元空间（本地实现）实现**

- 字符串常量池转移到堆中（可通过设置-Xmx和-Xms参数，创建静态字符串查看是否出现OOM）
- 静态/运行时常量池转移到元空间中
- PermSize和MaxPermSize参数移除

#### 1.5.1 JDK8之前
JDK8之前，这个区域更多称为永久代，虽然两者并不等价，因为仅仅是因为HotSpot选择把GC的分代设计扩展至方法区（用永久代来实现方法区），省去专门为方法区编写内存管理代码的工作量。而且该区域的可以选择不实现垃圾收集，所以垃圾收集行为在该区域较少出现，当方法区无法满足内存需要时，将抛出OOM

这种设计导致了Java应用更容易遇到OOM的问题
- 字符串存在永久代里，容易出现性能问题和瓶颈
- 类及方法信息很难确定大小，因此对于永久代的大小指定非常困难，太小容易OOM，太大容易导致老年代溢出
- 永久代为GC带来不必要的复杂度，并且回收率低

#### 1.5.2 JDK8
HotSpot与JRocket二合为一，使用本地内存（元空间）来实现方法区

在JDK7中，将字符串常量池/静态变量移出

JDK8完全废弃永久代，把JDK7中永久代的剩余内容（主要是类型信息）全部移到本地内存（元空间）中

![JDK8废除永久代](https://images2015.cnblogs.com/blog/584866/201704/584866-20170426154633834-741444326.jpg)

永久代（方法区的实现） : PermGen----->替换为Metaspace(本地内存/元空间)

#### 1.5.3 元空间

元空间是JDK8在虚拟机中对方法区的实现

元空间与永久代的最大不同是，**元空间并不在虚拟机中，而是使用本地内存**

通过设置 -XX:MetaspaceSize = ... -XX:MaxMetaspaceSize = ...，可以设置元空间的大小

#### 1.5.4 常量池
常量池有以下三种：
- 静态常量池（转移到元空间中）

    即*.class文件的常量池，在编译时加载

    这种常量池主要用于存放两大类常量：字面量、符号引用量（类和接口的全限定名、字段名称和限定符、方法名称和限定符）

- 运行时常量池（转移到元空间中）

    方法区的一部分，用于在类加载后存放常量池表和静态常量池的两大类常量

    相较于静态常量池，强调**具备动态性**，这也使得java不要求常量必须在编译期时才能产生，用得最多的就是string.intern()方法

- 字符串常量池（转移到堆中）

作用：
避免频繁的创建和销毁对象而影响性能，对象信息共享

    1. 节省内存空间，相同的常量都会被合并（字符串常量）

    2. 比如字符串使用==比equals更快的原因，对于两个引用常量，直接判断内存地址相等，也相当于判断实际值是否相等

#### **1.6 直接内存**

不是VM运行时数据区的一部分，也不是虚拟机规范中定义的内存区域

NIO引入了基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，再通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作，避免Java堆和Native堆中来回复制数据

**若忽略掉直接内存大小的限制，可能会导致各内存区域总和大于物理内存限制，导致OOM**

