# 基础概念

## 1. 硬件模型

![计算机存储系统](https://img-blog.csdn.net/20160730162807528)

存在问题：CPU与内存的读写速度存在巨大差异，CPU直接从内存读取数据需要等待一定的时间周期，

解决方法：通过在CPU内设置缓存（L1Cache，L2Cache和L3Cache），尽可能的读取更多的字节，寄存器可以通过缓存更快的获取到数据，减少CPU与内存之间运算速度的差异

**路线：CPU寄存器 -> store buffer（解决I状态通知造成的同步阻塞） -> L1Cache/L2Cache/L3Cache (invalid queue进行协同) -> Bus -> Memory -> Disk**

### 1.1 CPU

### 1.1.1 寄存器

寄存器是高速贮存部件，它一般用来暂存指令、数据和地址.在中央处理器的**控制部件**中，包含的寄存器有：**指令寄存器（IR）和程序计数器（PC）**；在**算术及逻辑部件**中，包含的寄存器有累加器（ACC）等

工作方式：
1. 找到相关的位
2. 读取这些位

### **1.1.2 高速缓存（L1Cache/L2Cache/L3Cache）**

![L1/L2核心独享，L3所有核心共享](https://upload-images.jianshu.io/upload_images/8124450-d18a6ea3d88249ac.png?imageMogr2/auto-orient/strip|imageView2/2/w/533/format/webp)

1. **作用**

    位于CPU与内存之间的一种容量很小的存储器，读写速度较快，尽力弥补了CPU与内存直接的读写差异

    高速缓存是内存的部分拷贝，它暂时存放内存中的数据，如果寄存器要取内存中的一部分数据时，直接在高速缓存中取到

2. **L1/L2/L3 Cache**

    L1，L2，L3 Cache分别称为一级，二级，三级缓存，L1缓存集成在CPU内部，L2和L3缓存早期焊在主板上，现在也都集成在CPU内部

    **L3为所有核心共享**

    ***容量：L1 Cache < L2 Cache < L3 Cache(各大CPU厂商目前更关注，因为不同CPU的L1和L2基本没差别)***

    ***速度：L1 Cache > L2 Cache > L3Cache***

3. **CacheLine 缓存行：**

    L1/L2/L3 Cache的最小单位，主流大小为64个字节

        数据在缓存中不是以独立形式存在的，假设访问一个long数组的某一项，当那一项的值被加载到缓存中，会额外加载另外七项，因此能很快地遍历这个数组

        因此，如果数据结构中的项在内存中不是相邻的，将得不到缓存行填充带来的优势

    一致性问题：

        缓存行填充机制会尽可能地填充相邻内存，直到缓存行填满
        
        但是多线程（多CPU核心）操作竞态变量下，若某一CPU核心率先操作成功，并将操作后的值放回自己的缓存行，其他CPU核心若无法感知到，则出现缓存不一致问题

        解决的方案：MESI协议保证安全，但会导致彼此影响（写回、失效、同步），性能下降

        eg：JVM的卡表机制与写屏障的引入，当在卡表同一内存区域的对象在标记脏表时，很容易产生缓存行伪共享问题（因为卡表是一个数组，卡表元素在物理上是相邻的）

### **1.1.3 MESI协议**

MESI协议解决的是多核心的L1/L2/L3缓存的一致性问题，当某CPU核心修改了共享缓存行的值，会发送invalid请求，通知其他CPU核心重新读取该缓存行，以保证每个缓存使用的共享变量是一致性的

因为缓存的一致性消息传递是需要时间的，在同步做法下，写线程会等待其他读线程的ACK，而读线程会在真正读取值后，再返回ACK。这个过程上读写线程都有一定程度上的阻塞，降低了性能

### **1.1.4 store buffer（存储缓存）**

**将写线程的等待ACK过程，过程进行异步化**

写线程将想刷新的值存入写缓冲器中，并发送invalid通知其他线程，接下来写线程关于该值的读取，优先从store buffer中读取（store forwarding）

等待其他线程都返回invalid ACK后，写线程再冲刷缓冲器的值到其他线程的高速缓存与内存中

### **1.1.5 invalid queue（失效/无效化队列）**

### 1.2 内存

用于存放数据的单元。其作用是用于**暂时存放CPU中的运算数据**，以及与**硬盘等外部存储器交换**的数据

工作方式：

1. 找到数据的指针。（指针可能存放在寄存器内，所以这一步就已经包括寄存器的全部工作了。）

2. 将指针送往内存管理单元（MMU），由MMU将虚拟的内存地址翻译成实际的物理地址。

3. 将物理地址送往内存控制器（memory controller），由内存控制器找出该地址在哪一根内存插槽（bank）上。

4. 确定数据在哪一个内存块（chunk）上，从该块读取数据。

5. 数据先送回内存控制器，再送回CPU，然后开始使用。

## **2. 进程与线程**

进程：操作系统分配资源和调度的基本单位，是代码在**数据集合上的一次运行活动**

线程：CPU资源分配的基本单位（最终占用CPU资源的是线程）

线程是进程中的一个实体，不能独立存在，是进程的一个执行路径。进程至少有一个线程，进程中的线程共享进程的资源

## 3. 线程的生命周期

![线程状态图](https://img-blog.csdnimg.cn/20190804232630162.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pkc2pseng=,size_16,color_FFFFFF,t_70)

![线程状态图，wait返回synchronized同步块](https://static.oschina.net/uploads/space/2018/0308/124802_AB5e_2885163.png)

### **2.1 状态**

```java
    /**
    * Thread.State枚举
    * @since 1.5
    * @see #getState
    */
    public enum State {
        NEW, // 创建状态
        RUNNABLE, // 运行状态
        BLOCKED, // 阻塞状态
        WAITING, // 无限期等待状态
        TIMED_WAITING, // 计时等待状态
        TERMINATED; // 终止状态
    }
```

1. New 创建状态

    new Thread()，线程对象被创建，但还未执行start()方法

2. Runnable 运行状态

    - READY：就绪状态，该状态下线程已获得除cpu资源外的其他资源（包括vm分配的虚拟机栈、本地方法栈和程序计数器）

        - 调用线程start()方法，进入就绪状态
        - **从锁池（Blocked）获得对象锁的线程，进入就绪状态**
        - 当前线程时间片用完了，调用当前线程的yield()方法，进入就绪状态
        - 当前线程sleep()方法结束
        - 当前线程对其他线程join()结束

    - RUNNING：执行状态，线程开始获得OS分配的cpu资源，执行工作

        根据OS调度，从就绪状态中的线程中取出一个进行执行

    调用new Thread().start()方法，首先进入READY就绪状态等待OS分配cpu时间片，在获得cpu资源后进入RUNNING状态

3. Blocked 阻塞状态

    线程在该状态下会等待获取监视器锁，以进入/重新进入synchronized块

    若线程在Runnable状态下获取监视器锁失败，会直接转换到Blocked状态

    **若线程在waiting或timed_waiting（调用obj.wait()方法），重新进入synchronized，会直接转换到Blocked状态**

4. Timed_waiting 计时等待状态

    在一定时间后被系统唤醒，一般是线程调用带超时参数的方法进入，如：Thread.sleep(long time) / thread.join(long time) / Object.wait(long time)

    进入Timed_waiting情况:
    - 当前线程调用监视器锁对象的wait(long time)方法
    - 当前线程调用线程静态方法，Thread.sleep(long time)
    - 当前线程调用其他线程对象的join(long time)方法

    退出Timed_waiting情况：
    - 当前获得监视器锁的线程执行notify/notifyAll()，唤醒后被加入到锁池中，进入blocked状态
    - 若是join(long time)调用的情况下，被调用join方法的线程完成任务后在超时时间内唤醒，进入blocked状态
    **- 超时时间到达，不管是调用Thread.sleep/thread.join方法，还是调用lockObj.wait()的线程，都会返回ready状态**

5. Waiting 无限期等待状态

    不会被分配cpu资源，需要显式唤醒(当前占用锁的线程使用notify/notifyAll()进行唤醒)，一般由持有锁的线程调用锁对象的wait()

    进入Waiting情况:
    
    - **当前线程调用监视器锁对象的wait()方法**
    - 当前线程调用其他线程对象的join()方法（**本质上会进入其他线程对象的同步块，调用线程对象的wait()方法**），等待该线程对象任务结束时被唤醒

    退出waiting情况：

    - wait()的情况下，其他线程在退出同步块/同步块中notify()，会唤醒等待集的线程(处于timed_waiting/waiting)，被唤醒线程会被加入到锁池中，进入blocked状态
    - join()的情况下，等待被调用join方法的线程完成任务后唤醒

6. Terminated 终止状态

    已终止状态，线程正常运行完毕或捕获异常中止

### **2.2 线程优先级**

```java
    /**
    * The minimum priority that a thread can have.
    */
    public final static int MIN_PRIORITY = 1;

    /**
    * The default priority that is assigned to a thread.
    */
    public final static int NORM_PRIORITY = 5;

    /**
    * The maximum priority that a thread can have.
    */
    public final static int MAX_PRIORITY = 10;

    private void init(...) {
        Thread parent = currentThread();
        this.priority = parent.getPriority();
        setPriority(priority);
    }
```

默认主线程的优先级为NORM_PRIORITY，在主线程创建的子线程优先级都为NORM_PRIORITY

### **2.3 锁池与等待队列**

每个对象都可以承担锁的功能，所以Java虚拟机会**为每个对象维护两个队列**，一个叫Entry Set(入口集)，另外一个叫Wait Set（等待集）

Entry Set（入口集/锁池/同步队列/monitor池）：存放想争夺对象锁的线程，池中的线程处于Blocked状态

Wait Set（等待集/等待队列/等待池）：存放执行了obj.wait()的线程，池中的线程处于Waiting状态

等待池中的线程被notify()或者notifyAll()方法唤醒进入到锁池，进入Blocked状态。最后竞争到了锁并且进入了Runnable状态的话，会从wait现场恢复，执行wait()方法之后的代码

    即被notify/notifyAll的线程（肯定处于obj的等待集），直接从Waiting =》 Blocked

![等待队列和同步队列](https://img-blog.csdnimg.cn/20190804232832471.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pkc2pseng=,size_16,color_FFFFFF,t_70)

```java
    /**
    * 状态转换demo
    * 异步线程1刚初始化: NEW
    * 异步线程1获得cpu资源，进入锁: RUNNABLE
    * 异步线程1主动wait: TIMED_WAITING
    * 异步线程2状态：NEW
    * 异步线程2状态：BLOCKED
    * 异步线程1调用wait之后: RUNNABLE
    * 主线程进入同步块
    * 异步线程2获得cpu资源，进入锁: RUNNABLE
    * 异步线程2调用wait之后: RUNNABLE
    * 执行使用的所有时间: 8.501
    */
    public class ThreadDemo implements Callable<Object> {
        public final static Object lock = new Object();

        public static FutureTask<Object> future = new FutureTask<>(new ThreadDemo());

        public static Thread thread = new Thread(future, "异步线程1");

        public static FutureTask<Object> future1 = new FutureTask<>(new ThreadDemo());

        public static Thread thread1 = new Thread(future1, "异步线程2");

        @Override
        public Object call() throws Exception {
            synchronized (lock) {
                Thread thread = Thread.currentThread();
                System.out.println(thread.getName() + "获得cpu资源，进入锁: " + getState(thread));
    //            lock.wait(10 * 1000);
                Thread.sleep(4 * 1000);
                System.out.println(thread.getName() + "调用wait之后: " + getState(thread));
                return null;
            }
        }

        private Thread.State getState(Thread thread) {
            return thread.getState();
        }

        public static void main(String[] args) throws Exception {
            long startTime = System.currentTimeMillis();
            System.out.println(ThreadDemo.thread.getName() + "刚初始化: " + ThreadDemo.thread.getState());
            ThreadDemo.thread.start();

            Thread.sleep(500);
            System.out.println(ThreadDemo.thread.getName() + "主动wait: " + ThreadDemo.thread.getState());

            System.out.println("异步线程2状态：" + ThreadDemo.thread1.getState());
            ThreadDemo.thread1.setPriority(Thread.MAX_PRIORITY);
            ThreadDemo.thread1.start();
            Thread.sleep(2 * 1000);
            System.out.println("异步线程2状态：" + ThreadDemo.thread1.getState());

            synchronized (ThreadDemo.lock) {
                System.out.println("主线程进入同步块");
                ThreadDemo.lock.notifyAll();
    //            System.out.println("异步线程1被主线程唤醒: " + ThreadDemo.thread.getState());

                Thread.sleep(500); // 持有锁不释放，异步线程会一直处于获取锁的状态
            }

            ThreadDemo.thread.join();
    //        System.out.println("完成任务后状态: " + ThreadDemo.thread.getState());

            ThreadDemo.thread1.join();
            System.out.println("执行使用的所有时间: " + ((System.currentTimeMillis() - startTime) * 0.001));
    }
```

### 2.4 **线程/监视器锁相关的方法**

```java
    Thread t = new Thread();

    Thread.sleep(10 * 1000);
    
    t.start();
    t.join();

    synchronized(obj) {
        obj.wait();
        obj.notify() / obj.notifyAll();
    }
```

#### 2.4.1 Thread.sleep(long time)

线程类的静态方法，使得当前执行的线程休眠time个时间。超时时间到了，则线程进入就绪状态

线程状态：running =》 timed_waiting =》 ready

#### 2.4.2 t.join() / t.join(long time)

```java
public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }
```

线程对象方法，使得当前执行的线程阻塞（waiting/timed_waiting），等待t线程消亡，当前线程才会继续执行

主线程调用t.join()抢到监视器t, 且t未消亡: running => waiting(t.wait()，需要t线程完成时唤醒) => blocked(主线程唤醒) => ready => running

主线程调用t.join()未抢到监视器t，且t未消亡: running => blocked(进入锁池) => waiting => blocked(主线程唤醒) => ready => running

主线程调用t.join(long time)抢到监视器t，且t未消亡：

running => timed_waiting => ready(wait时间到了) => 开始的running
                         => blocked(在wait时间内，t完成并唤醒)

#### 2.4.3 obj.wait() / obj.wait(long time)

当前线程调用后，将释放锁，并进入锁对象的等待集中

带参数会进入timed_waiting状态，超时会进入ready状态，显式唤醒都会使得线程重新进入blocked状态

不带参数进入waiting状态，则直接进入waiting状态，必须显式唤醒，唤醒后进入blocked状态

被唤醒的方式有
1. 获得监视器锁的线程调用锁的notify/notifyAll方法
2. 阻塞的线程的interrupt方法被调用

即使没有被notify/notifyAll()，线程也可能不符合预期的从等待状态变为运行状态，这种情况称为虚假唤醒

```java
synchronized(lock) {
    // 通过while，以符合预期执行的情况作为判断，来防止被莫名唤醒
    while (condition) {
        lock.wait();
    }
}
```

#### 2.4.2 obj.notify() / obj.notifyAll()

notify()会随机唤醒等待集的一个线程

notifyAll()会唤醒等待集的所有线程，被唤醒的线程全部加入到锁池中

# 参考
- [CPU缓存行的问题](https://www.cnblogs.com/jokerjason/p/9584402.html)
- [为什么会这么快？（二）神奇的缓存行填充](http://ifeve.com/disruptor-cacheline-padding/)
- [内存，寄存器和cache的区别与联系](https://www.cnblogs.com/zzdbullet/p/9484040.html)
- [CPU高速缓存行与内存关系 及并发MESI 协议](https://www.cnblogs.com/jokerjason/p/9584402.html)
- [CPU缓存一致性协议MESI](https://zhuanlan.zhihu.com/p/79777058)
- [JVM第四篇 程序计数器(PC寄存器)](https://www.cnblogs.com/niugang0920/p/12424671.html)
- [Java线程等待唤醒机制](https://blog.csdn.net/jdsjlzx/article/details/98470930)
- [为JAVA的线程设置优先级](http://www.dovov.com/java-462.html)
- **[wait()被唤醒后进入的状态](https://my.oschina.net/zjllovecode/blog/1630716)**
- [Java中的锁池和等待池](https://blog.csdn.net/qq_22498277/article/details/82184419)
- [wait()带参数的问题](http://bbs.itheima.com/thread-311354-1-1.html)
- [为什么wait通常要放在while中](https://zhuanlan.zhihu.com/p/89710060)