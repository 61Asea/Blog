# Java内存模型

为什么要并发：

CPU的高运算速度与I/O低存储通信速度，若大部分时间处于等待I/O情况，算力就得不到充分发挥。让计算机能同时处理几项任务，将大大提升CPU的利用率

一个服务器同时为多个客户端提供服务，TPS（每秒处理事务次数）是衡量服务器并发性能好坏的标准。对于计算量相同的任务，若并发协调好，则效率自然高；若线程之间频繁争夺资源，互相阻塞甚至死锁，将大大降低并发能力

解决思路：
    
    并发执行多个运算任务，并通过高速缓存缓解处理器与主存的缓慢交互



降低处理器与存储设备读写的巨大差距，在处理器与内存之间加入了一层或多层读写缓存（高速缓存/CPU工作内存），将**运算需要的数据复制到高速缓存中，在运算后写回主内存（内存）**，这种系统称为：**共享内存多核系统**

**工作内存存储在高速缓存和寄存器**

引入新问题：

    缓存一致性问题

    个人理解：缓存一致性问题不是由于高速缓存引入的，而是由于多处理器任务同时涉及主内存的同一区域导致


## 1. 指令重排序（提升CPU的算力）

为了使处理器的内部运算单元被充分利用，处理器会对输入代码进行重排序优化。保证结果与顺序执行的结果是一致的（如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性不能通过代码先后进行保证）

JIT也有指令重排序优化

## 2. Java内存模型

平台差异性：

因为不同架构的物理机器有不一样的内存模型，没有统一的内存模型去屏蔽各种硬件与操作系统的内存访问差异，会导致程序在不同平台上的并发处理异常

定义程序中各种变量的访问规则，关注虚拟机中把变量值存储到内存和从内存中取出变量值（变量指实例字段、静态字段和构成数组的元素）

局部变量和方法参数为线程私有，不会被共享，也自然没有竞争问题

### 2.1 主内存与工作内存

主内存：
- 可对比物理硬件的内存
- 可对比虚拟机视角的堆中的对象实例数据部分

所有变量都存储在主内存中

工作内存：
- 可对比物理硬件的高速缓存、寄存器
- 可对比虚拟机视角的虚拟机栈的部分区域

每条线程有自己的工作内存，工作内存存储了被线程使用的变量的**主内存副本**

访问关系：

线程对变量的操作都只能对工作内存进行，而不能直接读写主存，不同线程不能访问其他线程的工作内存，交互只能通过主存进行交互

虚拟机会让工作内存优先存储在寄存器和高速缓存上，程序运行时访问的主要是工作内存

### 2.2 内存间的交互操作



# 参考
- [深入理解JVM-第12章]()