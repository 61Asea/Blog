## **JVM**
### **1. Java内存区域 (运行时数据区域)**
Java内存区域和内存模型JMM是不同的东西
- **内存区域是指Jvm运行时将数据分区域存储，强调对内存的划分** 
- JMM定义了JVM在计算机内存的工作方式，与并发编程更相关

tip： 
#### 操作系统底层线程模型：
- 1:1模型

    使用内核线程实现，内核线程是直接由内核Kernel支持的线程，程序一般不会直接使用内核线程，而是用内核线程的一种轻量级线程接口（LWP）
    
    轻量级线程也就是**意义上的java多线程**，每个轻量级线程对应一个内核线程支持，俗称1:1

    内核线程保证了系统对线程的**可见性**，如果一个LWP线程阻塞了，也不会影响到同一进程上的另一LWP线程，进程不会因此阻塞

    缺点：每次切换都要从用户态->内核态->用户态

- n：1模型

    用户线程完全建立在用户空间的线程库上，可以简单理解为绑定在一个内核线程上，这种线程不需要切换内核态

    缺点：若一个用户态线程阻塞，整个进程阻塞。即线程操作由用户解决，阻塞处理十分困难，十分复杂

- m：n模型

#### Java的线程调度模型：抢占式调度
    每个线程都由系统分配执行时间，线程切换不依赖线程自己决定，若希望系统分配更多时间，则通过设置线程优先级来使得某些线程能在同一时间段内获得更多的操作时间

    总共有十个优先级Thread.MIN_PRIORITY至Thread.MAX_PRIORITY

#### **1.1 程序计数器（线程私有）**

是当前线程所执行的**字节码的行号指示器**，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令

它是**程序控制流的指示器，分支（if, switch/循环(iterator)/异常处理(try-catch)/线程恢复(yield,wait)等操作**等基础操作都需要计数器完成

由于程序在多线程下切换，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，**线程都需要有一个独立的计数器，各个线程之间的计数器互不影响**

如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；

#### **1.2 java虚拟机栈（线程私有）**
##### **栈帧**
- **局部变量表**

    堆栈分析中，栈分析中最多情况下的内容

    局部变量表存放了编译器可知的：
    - Java虚拟机基本数据类型（boolean/int/float/long/double）
    - 对象引用
    - returnAddress

    数据类型在局部变量中会以局部变量槽Slot来表示，double和long一般占用两个变量槽，这样在编译期通过后，局部变量表的大小是完全确定的，在方法运行期间也不会再改变局部变量表大小
    
    变量槽不固定具体比特大小，具体大小由对应虚拟机实现。

- 操作栈

    JVM的执行引擎是基于栈的操作引擎，其中的栈指的就是操作栈

- 动态连接
- 方法出口

Java虚拟机栈生命周期：与线程相同

描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧（Stack Frame）

**每个Java方法从调用到执行完毕，即对应一个栈帧从虚拟机栈中入栈到出栈的过程**

    在活动过程中，只有处于栈顶的栈帧才是有效的，成为当前栈帧，正在执行的方法称为当前方法，所有指令都只对当前栈帧做操作

    该模块区域可以认为是CPU高速缓存/寄存器（操作数栈）所使用的工作内存（局部变量表），但是不可能一概而论去与JMM进行对应
    
    因为JMM所为了解决对共享数据（简单认为是堆里的对象实例部分数据）读写一致性问题

    若以以上模型，JMM对应：主内存（堆）读取数据，加载到线程的工作内存中（局部变量表），内核级线程对应LWP，基于栈执行栈顶（操作数栈）得到结果，刷新工作内存，再通过工作内存刷回主内存，读写不一致也就是在此时出现

#### **1.3 本地方法栈**

与Vm Stack类似，用于Native方法调用

**栈深度溢出StackOverflowError， 栈扩展溢出OutOfMemoryError**

#### **1.4 Java堆**