# 基础概念

## 1. 进程与线程

进程：操作系统分配资源和调度的基本单位，是代码在**数据集合上的一次运行活动**

线程：CPU资源分配的基本单位（最终占用CPU资源的是线程）

线程是进程中的一个实体，不能独立存在，是进程的一个执行路径。进程至少有一个线程，进程中的线程共享进程的资源

## 2. 线程的状态

![线程状态图](https://img-blog.csdnimg.cn/20190804232630162.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pkc2pseng=,size_16,color_FFFFFF,t_70)

```java
/**
* Thread.State枚举
* @since 1.5
* @see #getState
*/
public enum State {
    NEW, // 创建状态
    RUNNABLE, // 运行状态
    BLOCKED, // 阻塞状态
    WAITING, // 无限期等待状态
    TIMED_WAITING, // 计时等待状态
    TERMINATED; // 终止状态
}
```
共六个状态：

**1. New 创建状态**

new Thread()，线程对象被创建，但还未执行start()方法

**2. Runnable 运行状态**

- READY：就绪状态，该状态下线程已获得除cpu资源外的其他资源（包括vm分配的虚拟机栈、本地方法栈和程序计数器）

- RUNNING：执行状态，线程开始获得OS分配的cpu资源，执行工作

调用new Thread().start()方法，首先进入READY就绪状态等待OS分配cpu时间片，在获得cpu资源后进入RUNNING状态

**3. Blocked 阻塞状态**

线程在该状态下会等待获取监视器锁，以进入/重新进入synchronized块

若线程在Runnable状态下获取监视器锁失败，会直接转换到Blocked状态

**4. Timed_waiting 计时等待状态**

 在一定时间后被系统唤醒，一般是线程调用带超时参数的方法进入，如：Thread.sleep(long time) / Thread.join(long time) / Object.wait(long time)

被notify/notifyAll()唤醒后被加入到锁池中，变为blocked状态

**5. Waiting 无限期等待状态**

不会被分配cpu资源，需要显式唤醒(当前占用锁的线程使用notify/notifyAll()进行唤醒)，一般由持有锁的线程调用锁对象的wait()/sleep()而进入

被notify/notifyAll()唤醒后被加入到锁池中，变为blocked状态

**6. Terminated 终止状态**

已终止状态，线程正常运行完毕或捕获异常中止

```java
 /**
 * 状态转换demo
 * 异步线程1刚初始化: NEW
 * 异步线程1获得cpu资源，进入锁: RUNNABLE
 * 异步线程1主动wait: TIMED_WAITING
 * 异步线程2状态：NEW
 * 异步线程2状态：BLOCKED
 * 异步线程1调用wait之后: RUNNABLE
 * 主线程进入同步块
 * 异步线程2获得cpu资源，进入锁: RUNNABLE
 * 异步线程2调用wait之后: RUNNABLE
 * 执行使用的所有时间: 8.501
 */
 public class ThreadDemo implements Callable<Object> {
    public final static Object lock = new Object();

    public static FutureTask<Object> future = new FutureTask<>(new ThreadDemo());

    public static Thread thread = new Thread(future, "异步线程1");

    public static FutureTask<Object> future1 = new FutureTask<>(new ThreadDemo());

    public static Thread thread1 = new Thread(future1, "异步线程2");

    @Override
    public Object call() throws Exception {
        synchronized (lock) {
            Thread thread = Thread.currentThread();
            System.out.println(thread.getName() + "获得cpu资源，进入锁: " + getState(thread));
//            lock.wait(10 * 1000);
            Thread.sleep(4 * 1000);
            System.out.println(thread.getName() + "调用wait之后: " + getState(thread));
            return null;
        }
    }

    private Thread.State getState(Thread thread) {
        return thread.getState();
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        System.out.println(ThreadDemo.thread.getName() + "刚初始化: " + ThreadDemo.thread.getState());
        ThreadDemo.thread.start();

        Thread.sleep(500);
        System.out.println(ThreadDemo.thread.getName() + "主动wait: " + ThreadDemo.thread.getState());

        System.out.println("异步线程2状态：" + ThreadDemo.thread1.getState());
        ThreadDemo.thread1.setPriority(Thread.MAX_PRIORITY);
        ThreadDemo.thread1.start();
        Thread.sleep(2 * 1000);
        System.out.println("异步线程2状态：" + ThreadDemo.thread1.getState());

        synchronized (ThreadDemo.lock) {
            System.out.println("主线程进入同步块");
            ThreadDemo.lock.notifyAll();
//            System.out.println("异步线程1被主线程唤醒: " + ThreadDemo.thread.getState());

            Thread.sleep(500); // 持有锁不释放，异步线程会一直处于获取锁的状态
        }

        ThreadDemo.thread.join();
//        System.out.println("完成任务后状态: " + ThreadDemo.thread.getState());

        ThreadDemo.thread1.join();
        System.out.println("执行使用的所有时间: " + ((System.currentTimeMillis() - startTime) * 0.001));
}
```

# 参考
- [Java线程等待唤醒机制](https://blog.csdn.net/jdsjlzx/article/details/98470930)