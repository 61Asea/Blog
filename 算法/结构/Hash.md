# HashTable

哈希表可以提供**快速查找**操作，插入和删除也接近O(1)时间级，是空间换时间策略的经典案例

顾名思义，它分为了哈希和表，哈希指的是哈希化/哈希函数；表指的是存储键值对的结构。综合在一起，就是**通过哈希函数，快速将Key转换为表的位置**

    这里不得不再提一下Java的Map，它是抽象的映射存储结构，具体实现思路有多种，包括本章节的哈希表

# **1. 底层结构**

哈希表是一种复合的数据结构，下层结构在正常情况下都是**通过数组实现**，数组元素存放键值对元素

- 存放Entry时，计算它的键哈希值（该值与**数组下标**为直接映射关系），将它存放在数组下标对应位置

- 获取Entry时，计算它的键哈希值，直接映射出数组下标，取出数组元素中的Entry

想象一下，元素的结构是怎么样的呢？是单个Entry，还是其他？

## **1.1 哈希冲突**

上述过程在每个Entry键所处数组下标都不同的情况下，看起来将十分美好，但是想象一下要实现这种美好，数组的大小将与Entry个数一致，当有无限的Entry时，数组大小也将会被无限延展

一般都是给定一个固定大小的数组，所以哈希函数必定涉及取模操作。这样一来，不同的Entry的键，可能会发生哈希化后的值相等的情况，这就是**哈希冲突**

因此，元素本身的结构取决于**解决哈希冲突**的方法：

- 开放地址法（探测序列使用再哈希法生成）

    结构：[Entry3, Entry1, null, Entry2]

- 链地址/拉链法

    结构：[{Entry1, Entry2, ...}, {Entry3}, {}, {Entry4}]

注意每个方法的缺点，开放地址法与底层数组的容量相关，而**拉链法涉及到装填因子**的概念，这些都与**哈希化结果分布均匀程度相关**！！！

    装填因子 = Entry个数 / 数组容量

## **1.1.1 开放地址法**

指定的数组大小，N倍（一般为2）于存储的数据量。当出现冲突时，因为有足够的位置存放冲突的元素，所以可以**再寻找一个新的位置**存放Entry

    这也意味着开放地址法的装填因子小于1，事实证明该方法在装填因子超过1/2或2/3后，性能下降快，这与聚集问题相关

寻找新位置的算法有以下三种：

1. 线性探测

    插入和查找都一样，数组下标一直递增一个步长，直到找到空白单元

    优点：简单、易实现

    缺点：哈希表变得越来越满时，元素会有严重的原始聚集情况，这增加了**探测长度**，性能下降严重；同时也会使得原始聚集扩张，发生冲突后都插在聚集的尾部

2. 二次探测

    插入和查找都一样，数组下标一直递增一个步长的平方，直到找到空白单元

    优点：防止线性探测导致的聚集扩张

    缺点：产生了二次聚集问题，因为所有映射到同一个位置的关键字在寻找空位时，探测的单元都是一样的

3. 再哈希法

    用不同的哈希函数，对键再哈希化，将这个结果作为步长

    第二个哈希函数需遵循：（1）与第一个哈希函数不同（2）不能输出0

        可以使用：stepSize = 容量 - (键 % 容量)

    优点：消除原始聚集和二次聚集

    缺点：要求哈希表的容量是一个质数，质数保证公式可以得到所有的单元下标，不然上述的公式会陷入死循环，非质数只会尝试某几个单元

总结：

开放地址法，底层数组的元素都是一个Entry，需要关注Entry的聚集问题，即数组容量

所以使用开放地址法策略时，一般采用再哈希法，避免原始聚集和二次聚集问题，但是要注意容量是质数

**而是否采用开放地址法，取决于是否能提前感知数据量，以及保证装填因子越小越好**

## **1.1.2 链地址法（拉链法）**

每个数组元素都是一个链表或数组（桶），每个Entry还是一样映射到数组元素，出现冲突时则插入到链表中

这可以保证秒插入，但是删除/查找效率，就受限于链表的长度了

- 装填因子

    因为在有N个单元数组中装入N个或更多的数据项，因此**装填因子可以大于1，且对性能影响不大**
    
    如果链表过长，查找的效率与链表长度成反比，因此**不希望链表太满**

- 数组容量

    不要求一定为质数，但是如果不为质数时，分布不均匀，容易造成元素上链表的聚集

- 链表

    长度过大，效率线性下降，在JDK8中，在长度超过8时，使用红黑树结构进行优化，牺牲些许插入性能来兼顾查找性能

总结：

链地址法是更健壮的机制，其装填因子可以达到1以上，且对性能影响不大。因为它将容量的问题完美地转换为了装载因子的问题，所以不需要事先确定哈希表需要存储多少数据

**后续介绍，会以拉链法作为主要切入点**

## **1.2 结构的优/缺点**

优点：

1. 哈希化结果作为数组下标，利用了数组的优势，快速定位获取数组下标元素

缺点：

1. 装载因子过大时，往往意味着链表会变长，性能下降严重，红黑树只能解决一定程度上的问题

2. 指标不治本，还是需要**在合适时机进行扩容**，即将数据转移到更大容量的哈希表中，成本包括：扩展数组和对键值对重哈希化

3. 因为是根据哈希来确定下标位置的，所以**数据存放是无序**的

# **2. 哈希函数**

## **2.1 具备条件**

```java
static final int hash(Object key) {
    int h;
    // key为null，则返回0；不为空，则返回hashCode与hashCode高16位的值异或的结果
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

final V putValue(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    // ...

    // i = (n - 1) & hash，获得数组下标
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
}
```

1. 快速计算

    越简单的哈希函数，计算越快速，如果哈希运算缓慢，速度就会降低

    JDKHashMap：

        第一步，将K的hashCode与其hashCode高16位的值进行异或，得出最终的hash值
        
        第二步，通过公式：(数组容量 - 1) & hash，得出数组下标

2. 分布随机且均匀

3. 

## **2.2 效率对比**

# 参考
- [Java数据结构与算法（第二版）：第十一章哈希表]()