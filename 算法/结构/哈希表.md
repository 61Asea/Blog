# 哈希表

哈希表可以提供**快速查找**操作，插入和删除也接近O(1)时间级，是空间换时间策略的经典案例

顾名思义，它分为了哈希和表，哈希指的是哈希化/哈希函数；表指的是存储键值对的结构。综合在一起，就是**通过哈希函数，快速将Key转换为表的位置**

    这里不得不再提一下Java的Map，它是抽象的映射存储结构，具体实现思路有多种，包括本章节的哈希表

## **底层结构**

哈希表是一种复合的数据结构，下层结构在正常情况下都是**通过数组实现**，数组元素存放键值对元素

- 存放Entry时，计算它的键哈希值（该值与**数组下标**为直接映射关系），将它存放在数组下标对应位置

- 获取Entry时，计算它的键哈希值，直接映射出数组下标，取出数组元素中的Entry

优点：

    哈希化结果作为数组下标，利用了数组的优势，快速定位获取数组下标元素

缺点：

    因为是根据哈希来确定下标位置的，所以数据存放是无序的

想象一下，元素的结构是怎么样的呢？是单个Entry，还是其他？Entry又是怎么和元素关联起来的呢？

# **1. 哈希化**

## **哈希码**

将关键字转化为一个数字类型的值，这个值就称为哈希码，哈希码主要用于哈希化操作，是哈希函数的参数

    在JDK8之前，通过随机数字生成哈希码

    在JDK8中，使用当前运行线程生成的随机数字，通过某种算法生成对象的哈希码

通过哈希函数，将**关键字的哈希码**转换为数组下标，这个过程称为哈希化

## **哈希函数**

哈希函数的目的是，将关键字的哈希码通过一种方式，转化为数组下标，这个方式应该符合以下两点：

1. 快速计算

    越简单的哈希函数，计算越快速，如果哈希运算缓慢，速度就会降低

2. 分布随机均匀

    哈希化属于将大范围转换为小范围，通过将哈希码和数组容量进行取模/与运算，将范围缩小
    
    然而以上相关运算，如果容量没有一个好的值，会导致分布不均匀，多个哈希码的计算结果可能是相同的，这会频繁引起哈希冲突

    取模：数组容量是质数

    与：数组容量为2的幂次方，减1后就变成了二进制位全是1的掩码，可以最大程度保留哈希码的原有低位的特征


分析一下JDK的HashMap的哈希函数：

```java
//第一步，将K的哈希码与其哈希码高16位的值进行异或，得出进一步的哈希码
static final int hash(Object key) {
    int h;
    // key为null，则返回0；不为空，则返回hashCode与hashCode高16位的值异或的结果
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

// 第二步，通过哈希函数公式：(数组容量 - 1) & hash，得出数组下标

final V putValue(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    // ...

    // i = (n - 1) & hash，获得数组下标
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
}
```

    数组下标 = (n - 1) & hash

可以看出HashMap使用的哈希函数采用的是"与"操作，所以最好能保证数组的长度为2的幂次方

    假设有一种情况，对象 A 的 hashCode 为 1000010001110001000001111000000，对象 B 的 hashCode 为 0111011100111000101000010100000

对象A和B的低6位，从低起数起都是0，在数组长度较小时，运算结果都为0，这样哈希函数将不会取得很好的效果

所以在运算获得数组下标前，HashMap还对哈希码进一步进行处理，通过

    进一步的哈希码 = (hash >>> 16) ^ hash

**使得哈希码的低位也能获得高位的特征**

## **2 哈希冲突**

通过以上的哈希化过程，我们将值大范围的哈希码，转化为了数组下标

但是不同的Entry的键哈希化后，仍然可能会出现数组下标相等的情况，这就是**哈希冲突**

**解决哈希冲突**的两种方法：

- 开放地址法（探测序列使用再哈希法生成）

    结构：[Entry3, Entry1, null, Entry2]

    在每个Entry键所处数组下标都不同的情况下，看起来将十分美好，但是想象一下要实现这种美好，数组的大小将与Entry个数至少一致（常常是两倍于数据量），当有无限的Entry时，数组大小也将会被无限延展

- 链地址/拉链法

    结构：[{Entry1, Entry2, ...}, {Entry3}, {}, {Entry4}]

    一般都是给定一个固定大小的数组，所以哈希化后，将值映射到下标，会涉及取模操作

由此可见，数组元素本身的结构取决于解决哈希冲突的方式

注意每个方法的缺点，**开放地址法与数组容量相关**，而**拉链法涉及到装填因子**的概念，这些都与**哈希化结果分布均匀程度相关**！！！

    装填因子 = Entry个数 / 数组容量

## **2.1 开放地址法**

指定的数组大小，N倍（一般为2）于存储的数据量。当出现冲突时，因为有足够的位置存放冲突的元素，所以可以**再寻找一个新的位置**存放Entry

    这也意味着开放地址法的装填因子小于1，事实证明该方法在装填因子超过1/2或2/3后，性能下降快，这与聚集问题相关

寻找新位置的算法有以下三种：

1. 线性探测

    插入和查找都一样，数组下标一直递增一个步长，直到找到空白单元

    优点：简单、易实现

    缺点：哈希表变得越来越满时，元素会有严重的原始聚集情况，这增加了**探测长度**，性能下降严重；同时也会使得原始聚集扩张，发生冲突后都插在聚集的尾部

2. 二次探测

    插入和查找都一样，数组下标一直递增一个步长的平方，直到找到空白单元

    优点：防止线性探测导致的聚集扩张

    缺点：产生了二次聚集问题，因为所有映射到同一个位置的关键字在寻找空位时，探测的单元都是一样的

3. 再哈希法

    用不同的哈希函数，对键再哈希化，将这个结果作为步长

    第二个哈希函数需遵循：（1）与第一个哈希函数不同（2）不能输出0

        可以使用：stepSize = 容量 - (键 % 容量)

    优点：消除原始聚集和二次聚集

    缺点：要求哈希表的容量是一个质数，质数保证公式可以得到所有的单元下标，不然上述的公式会陷入死循环，非质数只会尝试某几个单元

总结：

开放地址法，底层数组的元素都是一个Entry，需要关注Entry的聚集问题，即数组容量

所以使用开放地址法策略时，一般采用再哈希法，避免原始聚集和二次聚集问题，但是要注意容量是质数

**而是否采用开放地址法，取决于是否能提前感知数据量，以及保证装填因子越小越好**

## **2.2 链地址法（拉链法）**

每个数组元素都是一个链表或数组（桶），每个Entry还是一样映射到数组元素，出现冲突时则插入到链表中

这可以保证秒插入，但是删除/查找效率，就受限于链表的长度了

- 装填因子

    因为在有N个单元数组中装入N个或更多的数据项，因此**装填因子可以大于1，且对性能影响不大**
    
    如果链表过长，查找的效率与链表长度成反比，因此**不希望链表太满**

    其实装填因子，就是链表的平均长度，具体可以看第三点，关于链地址法的效率

- 数组容量

    不要求一定为质数，但是如果不为质数时，分布不均匀，容易造成元素上链表的聚集

- 链表

    长度过大，效率线性下降，在JDK8中，在长度超过8时，使用红黑树结构进行优化，牺牲些许插入性能来兼顾查找性能

总结：

链地址法是更健壮的机制，其装填因子可以达到1以上，且对性能影响不大。它将容量的问题转换为了装载因子的问题，所以不需要事先确定哈希表需要存储多少数据

装载因子越大，链表长度一定程度上也很大，这会降低查找的效率，在JDK中会有**链表转化红黑树**或**数组扩容**

容量最好也为质数，在哈希化/取模才能保证所有下标都能计算到，使分布更均匀

**在JDK中，就使用了拉链法的方式解决哈希冲突，后续介绍，会以拉链法作为主要切入点**

## **3 哈希化效率**

如果没有发生冲突，只需要使用一次哈希函数和数组的引用，就可以插入一个新数据项或找到一个已存在的数据项，这是最高效率情况

所以哈希化的效率好坏，往往取决于哈希冲突的严重程度。而哈希冲突的严重程度大小，往往又取决于**装载因子的大小**和**哈希函数的分布程度好坏**

接下来结合开放地址法和链地址法，介绍装载因子与哈希化效率相关程度

## **3.1 开放地址法**

    开放地址法因为装载因子降低哈希化效率的情况，比链地址法更严重

随着装填因子变大，哈希冲突越严重，**开放地址法的探测次数变多**，哈希化效率下降，增删改查都收到影响。

### **3.1.1 查找**

将开放地址法的查找(get方法)分为两种，进行分析：
- 成功查找

    在探测序列中，能找到要查找的数据项。平均起来，会走完序列的一半

- 不成功查找

    不能在探测序列中找到要查找的数据项，会走完整个探测序列

采用再哈希法（获取探测序列的最佳实践）：

| 装载因子 | 成功查找 | 不成功查找 |
| -----| ----- | ----- |
| 0.5 | 2 | 2 |
| 0.66(2/3) | 2.37 | 3 |
| 0.8 | 2.9 | 5.0 |
| 0.95 | 16 | 14 |

当装填因子>=0.8之后，开放地址法的探测长度将呈**指数型增长**

### **3.1.2 插入**

与查找过程相似

## **3.2 拉链法**

拉链法因其独特性质，在查找桶时只需计算一次哈希函数即可

所以拉链法插入一个新项较快，只需要找到桶位置即可，而查找则与链表桶的长度相关。冲突越严重，链表桶长度会变得更满，查找效率也将下降

可以很明显感受出来链表长度变长，对效率的影响是呈线性的

    探测长度 = 1（查找桶） + 比较链表的数据次数

假设哈希表有a个桶，共N个数据，每个数据项有一个链表，那么平均起来每个链表的长度为：

    链表长度 = N / a

可以发现链表长度与负载因子的定义是相同的:

    装载因子 = Entry个数 / 数组容量

所以**平均表长 = 装填因子**

### **3.2.1 查找**

不成功查找：1 + loadFactor

成功查找: 1 + loadFactor / 2

### **3.2.2 插入**

链表无序的，则插入立即完成；链表有序，按平均检查一半数据项，插入时间为loadFactor / 2

如果为红黑树实现，还需要考虑树的左旋右旋操作，树的遍历操作

## **4 总结**

### **4.1 哈希函数最佳实践**

越简单越好，关键点在于哈希码的均匀程度，哈希函数只是提供了一个掩码

JDK为了保证哈希码的均匀，进一步处理了哈希码

### **4.2 装载因子最佳实践**

当装载因子过大时，需要考虑**散列的扩容**，将装载因子重新降至一个合适的区间

然而扩容会带来高额成本，包括：扩展数组和对关键字重哈希化，所以**装载因子也不宜过小，否则容易触发扩容操作**

    在JDK的HashMap中，使用负载因子0.75作为默认因子

# 参考
- [Java数据结构与算法（第二版）：第十一章哈希表]()