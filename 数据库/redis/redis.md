# **Redis**
在DC的项目开发过程中，主要使用Redis用于：
- 作为游戏配置枚举的强一致性过期校验
- 实现对Node多进程的分布式锁

游戏配置基于DC的数值系统框架与服务端server mesh架构进行服务拆分，当其他业务子服务需要获得配置枚举时，都需要通过配置服务。这就需要考虑配置服务作为支撑服务在时刻内，需要向其他服务都提供最实时的数据。

为保证数据的强一致性，会在Redis中为各个枚举配置最新更新时间，当各个服务在获取枚举之前，都会先通过配置SDK，得到最新的枚举修改时间，并与本地枚举时间对比，若出现时间不一致情况，则从线上拉取最新配置。

对于node服务本身而言，为单线程非阻塞I/O模型，在实际开发中设计到并发时，都会通过采取PM2启动多节点的形式来提供平行性能。所以当涉及到多进程安全问题时，使用Redis的setnx原子操作，实现分布式锁。

这不同于java，java本身提供丰富的不同粒度的锁机制：synchronized与AQS显式锁可控制单节点上的线程安全。但当遇到多节点访问同一库源的情况下，也需要用到分布式锁。

# **模型**
单线程，因为Redis主要为内存存储介质，shell更多是操作服务器的内存，CPU并不是Redis的瓶颈。

采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。

采用多路复用I/O模型，通过select（无差别轮询）, poll（忙轮询，用户数组存储到内核链表，无连接数限制）, epoll（事件驱动）监察多个I/O流。与阻塞I/O模型类似，会阻塞掉I/O操作的两个阶段：
- 准备数据阶段
- 将内核数据(kernel)拷贝到用户内存

但多路复用可以等待多个数据包就绪，即可以处理多个连接，当某一路的数据准备就绪时，开始I/O操作。（与非阻塞I/O不同的是，非阻塞I/O不会直接阻塞掉用户进程，用户进程需要反复询问kernel数据）

![clipboard.png](https://segmentfault.com/img/bVbgA3t)

# **事务**

Redis中拥有操作序列，但这个序列并不能保证多连接并发操作时的原子性，所以需要通过WATCH监控内存是否发生改变，并通过MULTI与EXEC进行事务操作，这种做法类似于CAS乐观锁机制。

如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。

**若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行**

**若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常**

# **持久化**

两种：AOF和RDB，主流使用AOF持久化。当开启了持久化策略时，我们Redis更多是作为一种存储介质使用；而如果不开启持久化策略时，Redis将是一个高效的缓存方案。

## ***RDB***
RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。
- 手动触发分为save与bgsave，save会阻塞掉进程，导致不可用，bgsave则是fork出一个子进程进行数据持久（在fork过程会阻塞）
- 自动触发：bgsave m n，表示m秒内进行n次修改时，则自动触发
- RDB持久方式中，主流使用bgsave

### ***RDB的优点***
RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份， 并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），***用于灾难恢复***。

Redis加载RDB恢复数据远远快于AOF的方式。

### ***RDB的缺点***
RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运 都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。（一般作为时间段的备份方案，同时开启AOF）

RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。

针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。

## ***AOF***
AOF（append only file）持久化：***通过追加写命令到文件实现持久化***， 以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用解决了数据持久化的实时性，目前已经是Redis持久化的主流方式，类似于moongo等日志记录

- 所有的写入命令会追加到aof_buf（缓冲区）中
- AOF缓冲区根据对应的策略向硬盘做同步操作
- 随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的

如果每次写AOF文件命令都直接追加到硬盘，那么***性能完全取决于当前硬盘负载***。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。

## ***阻塞场景***
持久化阻塞主线程场景有：fork阻塞和AOF追加阻塞。fork阻塞时间 跟内存量和系统有关，AOF追加阻塞说明硬盘资源紧张

# 参考：
- [dackh-I/O模型总结](https://github.com/dackh/blog/blob/master/IO%E6%A8%A1%E5%9E%8B.md)
- [Redis入门指南]()
- [阻塞、非阻塞、多路复用等I/O模型](https://www.jianshu.com/p/b8203d46895c)
- [Redis持久化](https://www.jianshu.com/p/d3ba7b8ad964)
