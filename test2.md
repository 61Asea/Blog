主动引用
1. 遇到new、putstatic、getstatic、invokestatic四个字节码指令时，若类未初始化过，需要立即初始化
- new：创建对象实例
- putstatic：为类变量赋值
- getstatic：获取某个类变量（被final修饰的，会在编译时将结果存入到方法区中，不会初始化）
- invokestatic：调用某个类静态方法
2. 调用java.lang.reflect反射包，读取调用某种类型，若类型没有被初始化过，则初始化
3. 子类继承于父类，在子类初始化前，会先初始化父类
4. vm启动时，需要指定一个入口类，这个入口类会被初始化
5. 定义了default方法的接口，实现该接口的接口实现类在初始化时，会先初始化接口

加载：
1. 将类的二进制字节流加载到vm的内存中，这个过程需要验证阶段的文件格式验证
2. 将类的静态数据格式转换为动态运行时数据结构存储起来（将方法区中关于该类的静态常量池的数据存入到动态常量池中）
3. 在内存中生成一个java.lang.Class类，作为方法区该类型的方法访问入口和数据入口

第一点由于没有指定来源，这个空隙也创造了很多的读取方式：
1）从zip包，后发展为从war、jar、ear
2）从网络获取，如dubbo，applet
3）运行时计算生成，cglib
4）文件生成，jsp
5）从加密class文件获取

加载过程可以通过vm内置的加载器或者用户自定义的类加载器进行加载，重写findClass()和loadClass()方法，该过程也是类加载中除了初始化以外，能自定义的阶段

    数组类本身不通过类加载器进行创建，而是由vm创建，但是数组类的元素类型还是需要类加载器的加载

验证：

类二进制字节流可以从各种源头进行加载，需要进行验证，保证必要的安全

文件格式验证：

该阶段验证在加载阶段读取类二进制字节流时就已经开始

    验证魔数，检查主次版本号是否可为vm接受，是否有不存在的或不符合类型的常量

元数据验证：

    元数据信息的语言校验，主要验证：是否有父类（至少是Object），抽象方法有没有重写，final类是否被继承等

准备：

正式为类变量分配内存和赋值默认值，会在方法区中分配内存。此时，实例变量不会分配内存

一般情况下，会将类变量的赋值操作放到类的\<clinit>()方法中，等到类初始化的时候执行为类变量进行赋值。但如果是常量则在准备阶段就可以开始赋值

解析：

将符号引用转化为直接引用的阶段，为了支持java的晚期绑定，该阶段可以在类的初始化过程中再进行，以支持java的动态绑定

1）类和接口解析

若正在运行的代码在类D中，遇到了符号引用N，需要将其转化为直接引用类C或接口C：
- 若是数组类型，则vm会自行分配一份内存，直接引用为[java.lang.xxxx，并将其元素类型交由类D的类加载器进行加载
- 若不是数组类型，则直接交由类D的类加载器进行加载解析

2）字段解析

需要第一步的过程，转化字段表中的Constant_class_info符号引用，得到类C或接口C的直接引用：
1. 如果C本身就存在与字段相匹配的字段名描述符和名称的字段，则直接返回
2. 如果C实现了接口，则向上遍历父接口和接口列表搜索字段
3. 往C的父类进行遍历搜索，若有则直接返回

3）方法解析

与第二步类似，但因为是具体方法，C只能为类不能为接口

1. 第一步相同，会返回C相匹配的方法
2. 第二步的搜索，是针对C是类形式的搜索，当在父接口和接口列表搜索到时，说明C是一个抽象类，直接抛出抽象方法异常即可（抽象类方法必须被重写）
3. 第三步类似

4）接口方法解析

与第三步相反，C只能为接口不能为类

初始化：

类加载的最后一个步骤，除了在加载阶段可以显式地指定vm的类加载器，其他阶段都交由了vm自行处理，直到进入类初始化阶段

在该阶段中，真正的为类变量进行赋值，并通过构造器对实例变量进行赋值（若无显式赋值，则使用默认值）

    类初始化阶段会先调用类的\<clinit>()方法，该方法由类的静态语言块和类变量赋值组成，static块只能访问到定义在其之前的变量，之后的变量只能赋值不能访问

1）\<clinit>()与构造器不同，它不需要显式的调用，会保证父类的\<clinit>先行于子类执行完成
2）vm保证每个类的\<clinit>()方法只会被调用一次，某个线程执行时其他线程挂起等待，线程执行完毕后，其他线程将在唤醒后直接退出