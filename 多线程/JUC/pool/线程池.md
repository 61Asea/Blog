# 线程池

再一次提一下进程与线程的关系

进程
    
    操作系统分配资源与调度的基本单位，是代码在**数据集合上的一次运行活动**，即一个动态过程

线程

    程序执行流的最小执行单位，是进程中的实际运作单位，是**cpu资源分配的基本单位**

## **1. 概念（什么是线程池）**

    线程的集合，可以对线程的创建和销毁进行集中管理

java.util.concurrent.Executor接口用于实现线程池，可使用juc.Executors线程池工具类创建线程池，一般通过传入参数来定制初始化ThreadPoolExecutor

### **1.1 好处（为什么需要线程池）**

**线程池的核心优势：减少线程创建与销毁的开销**，个人认为也是进一步将任务与线程进行解耦

线程也是一个对象，创建一个对象，需要经过类加载的过程；销毁一个对象，需要经过GC回收流程，这两个过程都会有资源开销

实际运用上：
1. 提升任务的响应速度

    任务到达了，直接从池中可以拿到线程，省去了创建线程的时间

2. 重复利用

    使用过的线程，可以根据线程池的策略，进行重复回收，放回池中

3. 根据系统情况进行限制与动态调整

    限制系统中执行线程的数量，防止过多的线程消耗过多的内存
    
    并可根据系统的承受能力，动态调整工作线程的数目。线程不是越多越好（毕竟CPU核心数是固定的），线程切换的开销也需要兼顾

4. 任务与线程进行解耦

    任务无需关注线程的生命管理，线程也无需关注任务的执行细节

    再通过线程池，线程真正做到了可以只关注于执行，其生命管理由线程池控制

### **1.2 线程池使用场景（什么时候用线程池）**

假设一个服务器完成一项任务的所需时间为：T1（创建线程的时间）、T2（在线程中执行任务的时间）、T3（销毁任务线程的时间）

如果T1 + T3 远大于T2，则应该考虑线程池，以提高服务器的性能

## **2. 线程池的结构**

![线程池的接口/实现类结构](https://img2018.cnblogs.com/i-beta/1378444/201911/1378444-20191125143829962-1722847086.png)

一个线程池的构成基本分为四大部分：

1. 线程池管理器（ThreadPool）：用于创建并管理线程池，包括：创建线程池、销毁线程池和添加新任务

2. 工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务

3. 任务接口（Task）；每个任务必须实现的接口，以供工作线程调度任务的执行，它规定了任务的入口，任务执行后的收尾工作、任务的状态等

4. 任务队列（TaskQueue）：用于存放没有处理的任务，提供了忙时的缓冲机制

## **2.1 线程池接口行为**

### **2.1.1 Executor接口**

线程池最上层的接口，定义了线程池子类都需要实现execute方法接口

```java
public interface Executor {
    /**
     * Executes the given command at some time in the future.  The command
     * may execute in a new thread, in a pooled thread, or in the calling
     * thread, at the discretion of the {@code Executor} implementation.
     *
     * @param command the runnable task
     * @throws RejectedExecutionException if this task cannot be
     * accepted for execution
     * @throws NullPointerException if command is null
     */

     // 任务可能在一个新的线程中执行（线程池扩容）；在池中已经有的线程执行；活着在回调中被执行
    void Execute(Runnable command);
}
```

### **2.1.2 ExecutorService (extends Executor)**

抽象出了 **线程池管理器ThreadPool** 需要提供的行为接口，这包括：

1. 管理终止（termination/shutdown）

2. 返回任务包装后的Future对象，以跟踪/取消异步任务的运行情况

该接口规定了**除调度线程池外的线程池应具有的行为**，至关重要。其有实现抽象类AbstractExecutorService，以及继承抽象类的具体实现子类ThreadPoolExecutor类

```java
public interface ExecutorService extends Executor {
    /**
        一、管理终止：
            1. shutdown
            2. shutdownNow
            3. isShutdown
            4. isTerminated
            5. awaitTermination

        提供了两种不同的方法来关闭线程池：shutdown和shutdownNow，一个线程池在不允许接收新任务，没有等待执行的任务并且没有正在执行的任务时，应该关闭池以回收资源
    */

    // 该方法允许在终止之前执行正在等待的（以前提交的）任务
    void shutdown();

    // 阻止正在等待的（以前提交的）任务的执行，并试图停止当前正在执行的任务
    List<Runnable> shutdownNow();

    boolean isShutdown();

    boolean isTerminated();

    boolean awaitTermination(long timeout, TimeUnit unit);

    /** 
        二、提交任务到线程池的接口行为
            1. submit(Callable<T> task)
            2. submit(Runnable task, T results)
            3. submit(Runnable task)
            4. invokeAll及其超时等待版本
            6. invokeAny及其超时等待版本

        submit方法，单任务提交的形式，它扩展了父接口的execute方法，提供可取消/跟踪异步任务的Future对象

        invokeXXX方法，任务批量提交的形式，执行一组任务，然后等待其中一个或全部任务完成
    */

    <T> Future<T> submit(Callable<T> task);

    <T> Future<T> submit(Runnable task, T result);

    Future<?> submit(Runnable task);

    // 返回全部完成任务的结果
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;

    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit timeunit);

    // 返回任一完成任务的结果，在正常返回或出异常时，其他未执行的任务将回被取消（即tasks只会有一个任务被完成？？？）
    <T> T invokeAny(Collection<? extends Callable<T>> tasks);

    <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit timeunit);
}
```

### **2.1.3 ScheduledExecutorService**

```java
```

# 参考
- [线程池概念和作用](https://blog.csdn.net/li1325169021/article/details/113897919)
- [Java线程池解析](https://zhuanlan.zhihu.com/p/73990200)
- [线程池类图详解](https://www.cnblogs.com/minikobe/p/11927658.html)

- [Executor.java]()
- [ExecutorService.java]()