# 红黑树

普通的二叉搜索树，可以快速地找到一个给定关键字的数据项，并且可以快速地插入和删除数据项

但是二叉搜索树如果**插入有序数据，会变为非平衡**，最差平衡情况下，退化为链表

红黑树，通过红黑规则保证了树是平衡的，它是增加了某些特点的二叉搜索树

# **1. 红黑规则**

当插入（或者删除）一个新节点时，必须要遵循的一定的规则，如果遵守这些规则，树就是平衡的：

1. 每一个节点不是红色的就是黑色的

2. 根节点总是黑色的

3. 如果节点是红色的，则它的子节点必须是黑色的

    黑色节点的子节点没有限制，不一定是红色

4. 从根节点到叶子节点或**空子节点**的每条路径，必须**包含相同数目的黑色节点**，即**黑色高度相同**

    空子节点：非叶节点可以接子节点的位置

        就是一个有右子节点的节点的可能接左子节点的位置，或者有左子节点的节点的可能接右子节点的位置

5. 如果有跟节点值相同的新节点插入，应该**先插入在节点的右边**

# **2. 旋转操作**

只要一个节点的左边有很多子孙节点，而右边没有这么多节点，就可以向右旋转；反之亦然

以一颗二叉平衡搜素树为例，父节点为50，左子节点为25，右子节点为75，高度为2

## 选择旋转的顶端节点

    可以用轮胎来比喻这个过程，这个节点不是轮轴，而是轮胎胎面最上面的部分

注意选择的节点，并不是旋转操作的**轴心**，它是旋转操作的顶端节点

## 左旋

    做左旋，必须保证顶端节点有一个右子节点

对一个节点进行左旋，则它的右子节点将取代它变成新的顶端节点，它的子孙节点将跟它一起变成新顶端节点的子节点，而它则变成了新顶端节点的左子节点

## 右旋（基准）

    做右旋，必须保证顶端节点有一个左子节点

对一个节点进行右旋，则它的左子节点将取代它变成新的顶端节点，它的右子节点将变成新的顶端节点的子孙节点，且仍是它的右子节点

## 横向移动节点

如果例子中的左子节点25，本身还有左子节点12和右子节点37，做右旋时就出现问题了，因为父节点会变成25的右子节点，这样25就有两个右子节点，一个是37，一个是新的50

我们将越靠近父节点路径中心轴的子孙，称为内侧

子孙37这个节点称为50的**内侧子孙**，12这个节点称为50的**外侧子孙**

解决的方式为：

    对于内侧子孙而言，如果它是上移节点的子节点（在左旋中，是顶端节点的右子节点；在右旋中，是顶端节点的左子节点），它总是要断开和上移节点的连接，并且重新连接到它以前的祖父节点上

    如果是左内侧节点，则连接到祖父节点的左子节点；
    如果是右内侧节点，则连接到祖父节点的右子节点；

# **3. 操作步骤（插入）**

当树不符合以上红黑规则时，使用两个举措修正树，使得树再次遵守上述规则：
- 改变节点的颜色：改变节点的**红-黑边界的颜色**
- 执行旋转操作：左旋/右旋

依照红黑规则，分为三步：
1. 自顶向下查找插入的位置，如果在这个过程中发现存在**两个红子节点的黑色节点**，将红-黑边界颜色调换（子节点变成黑色，父节点变成红色），最后插入节点

2. 如果上一步导致违反了规则3（调换红-黑边界时导致两个红色节点相连），则采取以下的举措进行旋转修正，**这里应该以刚做了颜色变换的顶端节点作为基准**，我们称为P
    1. 如果P为其祖父节点的**外侧子孙**

            该过程需要两次颜色变换和一次旋转操作

        - P的父节点颜色变换
        - P的祖父节点颜色变换
        - 以P的祖父节点作为顶端节点，进行左/右旋（如果是在左子树，则往右旋；反之亦然）

    2. 如果P为其祖父节点的**内侧子孙**，将其先修正为**外侧子孙**

            该过程需要两次颜色变换和两次旋转操作

        - P自身颜色变换
        - P的祖父节点颜色变换
        - 以P的父节点作为顶端节点，进行左/右旋，将插入节点修正为外侧子孙
        - 以P的祖父节点作为顶端节点，进行左/右旋

3. 如果上述过程都正常，但是在最后插入的时候，发现父节点为红色节点，则采用第二步的两种举措进行旋转修正

# **4. HashMap的红黑树**

HashMap在桶的长度大于等于8时，会尝试将桶链表树化

```java
final void treeifyBin(Node<K,V>[] tab, int hash) {
    int n, index; Node<K,V> e;
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
        resize();
    else if ((e = tab[index = (n - 1) & hash]) != null) {
        TreeNode<K,V> hd = null, tl = null;
        do {
            TreeNode<K,V> p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}
```

将链表节点都替换为红黑树节点（链表会有前后引用，即双向链表）后，调用头节点的treeify方法进行树化

## **4.1 红黑树节点结构**




# 参考
- [Java数据结构与算法第二版-红黑树]()