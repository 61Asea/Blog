# 多叉树（2-3-4树、2-3树和B-树）

二叉树，指的是节点只有一个数据，且**最多两个子节点**的树

> [二叉树](https://asea-cch.life/achrives/binarytree)

多叉树，指的是节点可以有**更多数据项**，且可以**超过两个子节点链路**的树

**B-树**就是多叉树中的一种，而2-3树/2-3-4树分别是B-树的**2节点/3节点特例**

    以上提到的2-3-4树、2-3树和B-树，都是绝对平衡树，即它们的叶子节点都在同一层上

2-3-4树，2-3树，B-树的平衡方式，是通过插入操作对满节点的分裂进行的，这在后续会着重分析

# **1. 2-3-4树**

2-3-4树晚于2-3树提出，是B-树的一种特例，其也可以称为四叉树，因为节点最多可以有四个链接

## **1.1 节点**

2、3、4的含义是指一个节点可能含有的子节点的个数：
- 有一个数据项的节点总是有两个子节点
- 有两个数据项的节点总是有三个子节点
- 有三个数据项的节点总是有四个子节点

简言之，**非叶节点**的子节点数总是比它的数据项多1，在2-3-4树中，不允许只有一个链接，有**一个数据项的节点必须总是保持两个链接**，除非它是叶子节点

![2-3-4树的节点](https://asea-cch.life/upload/2021/06/2-3-4%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9-fea92464c66442bfba837fc7baae8d32.png)

如图所示，有两个链接的节点称为2-节点，有三个链接的称为3-节点，有四个链接的称为4-节点，但没有称为1-节点的节点

节点内**数据项的组织方式是升序排列**的，对子节点的链接也是按照关键字值的对比结果进行链接

![节点数据项组织](https://asea-cch.life/upload/2021/06/%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%BB%84%E7%BB%87-d8d23241da1e4fe38458caac47af40ff.png)

## **1.2 红黑树同构**

可以论证红黑树与2-3-4树**存在互相转化关系**，它们俩是完全相同的，可以通过一些简单的规则变成另外一种树，且使它们保持平衡的操作也可以转化为一致的操作语义，数学上称为**同构**

## **1.3 关键操作**

### **1.3.1 查找**

查找给定的关键字值数据项的方式，与二叉树的查找方式有着异曲同工之妙

从根节点开始，通过与节点的数据项进行对比，如果值就在节点上，则返回；否则，选择处于范围内的两个数据项的链接，转向子节点

### **1.3.2 插入**

    插入操作是2-3-4树，乃至B-树保持树绝对平衡的方式

讨论自顶向下的2-3-4树，**新的数据项总是插在叶节点里**，并根据叶节点数据项的大小进行排序变化，保证数据项一直处于升序状态

查找时如果没有遇到满数据项的节点，则直接在合适的叶节点插入即可；如果在下行过程中，遇到了有满数据项的节点（包括叶节点），则需要**对节点进行分裂，再执行插入操作**

#### **节点分裂**

    注意：2-3-4树的节点分裂，是在向下找到插入点的路途中节点发生分裂，再执行插入操作

如果往下查找要插入的路径中，发现有节点已经满了，则对该节点进行分裂

![2-3-4分裂](https://asea-cch.life/upload/2021/06/2-3-4%E5%88%86%E8%A3%82-2964b4c3b88d40e19f38b605b5e5f156.png)

节点中的三个数据项应是升序排列的，则分裂的规则如下：

- 第一个节点**保留在原节点**中
- 第二个节点**上移到父节点**中
- 第三个节点**右移到新节点**中，新节点是要分裂节点的兄弟，在分裂节点的右边
- 分裂节点最右和次右两个子节点从分裂处断开，并链接到新节点上

这个过程，就是将一个4-节点**等价转换**为两个2-节点，通过把数据**向上和向右移动**，可以使得树保持在绝对平衡状态

    因为是在向下查找过程中分裂节点的，所以不存在分裂节点的父节点是满节点，即不会出现分裂回波

当下行过程中不只遇到一个满节点，则会进行**多重分裂**，如果根节点就是满节点，则数据的向上移动将变为创建新的根节点操作
    
## **1.4 效率**

### **时间复杂度**

在相同个数的数据项下，相较于正常的红黑树

    红黑树高度：log2(N+1)

考虑到2-3-4树并不是每个节点都满，可通过以下结论推导

    2-3-4树最少高度：log4(N+1) => log2(N+1)/2

    2-3-4树最多高度：log2(N+1)

    2-3-4树的高度范围：log2(N+1)/2到log2(N+1)之间

在大部分情况下，**2-3-4树的层数都会较少**，查找节点是与层数成正比的，所以2-3-4树的较少层数可以使其查找时间短一些

但是注意，每个节点最多有3个数据项，而红黑树的节点只有1个数据项，2-3-4树中增加每个节点的数据项数量可以抵偿树的高度减少，得出最后结论：**2-3-4树与红黑树的查找时间大致相同**


    时间复杂度：O(logN)

### **空间复杂度**

因为节点不可能全是满的，而红黑树的每个节点有且必有一个数据项，所以红黑树的空间利用率比2-3-4树更好

### **综合考虑**

2-3-4树带来最大的优势，就是**将树的高度削短**

如果节点数据项最大数量不只是4个，可以是多个，那么树的高度将会变得更低

# **2. 2-3树**

2-3树是第一种多叉树，在1970年被提出（B-树在随后1972年被提出），其技术在B-树中应用，且与2-3-4树有很大的类似性

## **2.1 节点**

节点的数据项最多有2个，子节点数最多有3个，即2-节点和3-节点

所有的新数据项也是插入到叶节点中，所有叶节点都在同一层上

## **2.2. 节点分裂**

    注意：2-3树的分裂过程需要新插入的数据项参与，因为2-3树只有两个数据项，无法找出应该上移的中间数据项，所以应是插入后再进行分裂

因为2-3树是插入后再进行分裂的，所以插入项一定要到达叶节点进行插入

一样认为节点的数据项是升序排列的，2-3树的分裂过程如下：
- 将新插入的节点与节点的两个数据项进行排序，得出新的升序序列
- 第一个数据项留在本节点中
- 第二个数据项移到上个节点中
- 第三个数据项移到新节点中，新节点仍为分裂节点的右兄弟节点

因为不是在下行过程中进行分裂，而是**自底向上**，这将会遇到**分裂回波**的问题

![2-3树的分裂](https://asea-cch.life/upload/2021/06/2-3%E6%A0%91%E7%9A%84%E5%88%86%E8%A3%82-ed722ee3bb6140259a482d8dc7db0cde.png)

# **3. B-树**

    2-3树和2-3-4树问题的本质，可以认为是节点的数据项的奇/偶数个问题

奇数个项节点的树：可以轻松地将数据项分为左数据项集合、中间数据项、右数据项集合三个部分，并将中间数据项认定为上移节点，所以分裂过程可以是**自顶向下的**

偶数个项节点的树：只能分为左/右数据集合两个部分，此时就需要新插入的数据项做配合，找出中间数据项，所以分裂过程应是**自底向上的**

根据以上的总结，我们引入1972年提出的B-树，2-3树和2-3-4树是它的奇数据项和偶数据项的特例，B-树更**强调每个节点含有很多的子节点**

## **3.1 外部存储**

> [内存条的读取速度比硬盘到底快多少倍？](https://www.zhihu.com/question/266375329)
    
    RAM，随机存取存储器，主存的存储介质，它可随时读写，速度在CPU之下，当电源关闭时RAM不能保留数据

    MSM-ODM，外存的存储介质，能长期保存信息，并且不依赖于电来保存，由机械部件带动，读写速度与RAM相差甚远

    磁盘读写机制：切换到对应数据的磁道，读写头等待数据旋转到正确位置

> [块存储、文件存储、对象存储这三者的本质差别是什么](https://www.zhihu.com/question/21536660)

    所有数据按照固定的大小分块，每一块赋予一个用于寻址的编号，现代机械硬盘用一个逻辑块编号寻址（LBA），所以硬盘设备往往又叫做块设备

I/O开销就来源于内存与磁盘的读写速度差异，磁盘切换磁道与旋转数据的开销巨大，但是当到达正确位置后，读取块的速度极快

块的容量与读写效率成正比，我们希望尽可能地从磁盘读取更多的数据到主存中，以减少访问磁盘的次数

    思考1：如果使用数组/链表结构来存储块，会有什么问题？

答案显而易见：数组结构可以提供顺序存储，但如果需要在数据中间插入新数据，会使得插入位置之后的数据都移动，这将造成对后续全部块的读与写共计两次操作，这将是致命的

而链表不能够提供随机访问性，这意味着在链表中找到块数据，需要从头开始遍历

当然，也可以使用索引来对数组进行优化，使得数组的顺序为插入顺序，而磁块的逻辑号由索引维护

## **3.2 阶数与效率**

    思考2：在二叉树中提到了，树可以综合数组和链表的优缺点，那么使用红黑树来存储块，可以吗？

相比数组和链表，红黑树较快的查找速度，与几乎为零的移动成本，是不错的选择

    红黑树的查找次数：O(logN)

红黑树的每个节点只能有一个数据项，一个块的数据可能会分配到很多的树节点上，考虑到I/O读写的效率，我们希望在节点上尽可能地读取更多的数据，因为块容量越大，读写效率越高

    2-3树的查找次数：O(log3N) ~ O(logN)

    2-3-4树的查找次数：O(log2N) / 2 ~ O(logN)

假设B-树的每个节点存储的就是一个块的数据，且块中数据个数一般为偶数个，则采用偶数个数的2-3树变式，这样B-树的查找效率则与其节点能存的**数据项个数a**成正比

    B-树的查找次数：O(logaN) ~ O(logN)

所以，B-树会更适合于存储系统，因为它的节点数据项尽可能多，可以**更大程度地降低树的高度，减少访问磁盘的次数**

这里引入阶数的概念：B-树的阶数，为节点内最大可存数据项个数 + 1

# 参考
- [《Java数据结构与算法》第2版第10章：2-3-4树]()
- [块存储、文件存储、对象存储这三者的本质差别是什么](https://www.zhihu.com/question/21536660)