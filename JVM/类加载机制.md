# 类加载机制

vm将描述类的数据从Class文件加载到内存中，并对数据进行校验、转换解析和初始化，最终形成可以被vm直接使用的Java类型

加载、连接和初始化，都是在**程序运行期间完成**，这种策略使得提前编译变得困难（方法区静态变量池存放两大类常量），使得类加载时会稍微增加性能开销（静态常量池数据存入运行时常量池，以及加载、连接和初始化），但是却提供了灵活性和扩展性

## 1. 类加载时机

加载/连接/初始化都是在**程序运行期间完成的**，**加载、验证、准备、初始化、卸载**这个5个阶段的顺序是确定的，类的加载必须严格按照这种顺序开始。而在这个顺序中的各个阶段，通常是混合交叉进行，会在一个阶段执行的过程中，调用激活另一个阶段。但整体上看，其他阶段的最终还是需要上个阶段的完成。

解析阶段可以在初始化之后再开始，这是为了**支持Java的运行时绑定（动态绑定｜晚期绑定）**

虚拟机的具体实现会自由**把握类加载过程的加载阶段”**，但是对于**初始化阶段（加载、验证、准备需要在此之前开始）**

严格规定了有且只有6种情况必须立即对类型进行“初始化”：
- 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段
    - new：使用new关键字实例化对象时
    - getstatic/putstatic：读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候
    - invokestatic: 调用一个类的静态方法时
- 使用反射包对类型进行反射调用时，没有被初始化过，则先触发其初始化
- 初始化类时，发现父类还没有进行过初始化，则需要先触发其父类的初始化
- vm启动时，需要指定main主类，vm也会先初始化该主入口类
- 动态语言支持（不管）
- 定义default接口方法的接口，其实现类发生了初始化时，接口应先被初始化

## 2. 类的生命周期

- 加载（可参考ClassLoader的loadClass方法）

    通过一个类的全限定名将类二进制字节流流加载到内存，并在内存中生成一个java.lang.Class对象，作为**方法区这个类的各种数据访问入口**

    知识点：方法区运行时常量池和静态常量池的区别，静态常量池在编译的时候存放类的字面量和符号引用，在**类加载时**，静态常量池的数据会存入到运行时常量池中

    常量池存放：类名/类访问修饰符/常量池/字段描述/方法描述

- 连接
    - 验证
    - 准备

        正式为类变量分配内存并设置类变量初始值，这些变量所使用的内存都将在方法区中分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），不包括实例变量，实例对象会随着对象实例化（初始化）随着对象一起分配到堆中

    - 解析

- 初始化
- 使用
- 卸载

## 3. 双亲委托机制