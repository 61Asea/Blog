## **HotSpot经典垃圾收集器合集**

### **F大引言-HotSpot各大收集器的开发历史**

一开始只有**NewGeneration**，后来HotSpot团队准备加入young gen的并行GC：
1. 把**原本的NewGeneration改名为DefNewGeneration**
2. 并把新加入的并行版本叫**ParNewGeneration**

Parallel Scavenge开发团队不希望在HotSpot的分代式框架中憋着，自己实现了框架以外的新并行GC，结果就是HotSpot开发团队需要维护两个功能一致，但实现细节各自为盟的两个GC

Scavenge收集就是新生代的copying算法的另一种别称，**HotSpot里的所有GC都是在minor GC阶段使用scavenging**，DefNew（Serial GC）、ParNew和Parallel Scavenge都是

    把GC并行化的目的是想提高GC速度，也就是提高吞吐量（throughput）
    
    所以其实ParNew与ParallelScavenge都可叫做Throughput GC

    但是在HotSpot VM的术语里“Throughput GC”通常特指“ParallelScavenge”

Parallel Scavenge和ParNew GC都是属于并行GC，主要是并行收集**young GC**，目的和性能都差不多，最明显的区别有以下几点：
1. 遍历对象图时：Parallel Scavenge深度优先遍历，ParNew广度优先遍历
2. PS完整得实现了自适应大小策略（adaptive size policy），而ParNew及“分代式框架”内的其它GC都没有完全实现，千万不要在ParNew+CMS组合下使用该参数，该参数在CMS组合策略中默认关闭
3. ParNew可以跟CMS搭配使用，而Parallel Scavenge不行

    最初的Parallel Scavenge目标只是并行收集young gen，核心收集器在PSScavenge中，而full GC还是与Serial Old GC一致，但称为PSMarkSweep的收集器

    该收集器其实只是在Serial old gc的外表上套了一层皮，本质上还是一样的LISP2的mark-compact标记整理算法

![](https://img-blog.csdnimg.cn/20200824180142102.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNjkyOTQ=,size_16,color_FFFFFF,t_70#pic_center)
![](https://img-blog.csdnimg.cn/20200824181722627.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNjkyOTQ=,size_16,color_FFFFFF,t_70#pic_center)

### **控制吞吐量与延迟**

吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 运行垃圾收集时间）

降低整体垃圾收集时间，会增加用户代码运行的时间，在整体而言吞吐量就上去了（但也意味着单次GC的时间延迟可能会变大，高延迟会带来糟糕体验）

降低最大垃圾收集时间（单次GC时间），常会导致发生GC频率变高，使得总体垃圾收集时间占比变高，使得吞吐量下去

低延迟：服务的响应速度更快，希望系统停顿时间尽可能短

#### **1. 新生代收集器**

#### **1.1. Serial收集器（Serial Young GC）**

client模式下的默认收集器，具有额外内存小号最小，简单，与其他收集器的单程效率相比更为高效

单线程，强调它在进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束

STW是虚拟机在后台自动发起和自动完成的，在用户不可知、不可控的情况下把用户的正常工作的线程全部停掉

努力方向：降低用户线程因为垃圾收集而导致的停顿

算法：标记-复制算法，Scavenge/copying GC

#### **1.2. ParNew收集器**

实际上是Serial收集器的多线程并行版本，除了同时使用多条线程进行收集之外，其他的收集器使用参数、收集算法、Stop the World、对象分配规则、回收策略等都与SerialGC完全一致

目前与CMS搭配的唯一直选，在JDK9开始之后，直接取消使用了+XX:UseParNewGC参数，ParNewGC并入CMS，成为CMS的专门处理组成成分

默认开启的垃圾收集线程与处理核心线程数量相同，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数

实现算法：标记-复制算法，Scavenge/copying GC （并行版本）

#### **1.3. Parallel Scavenge收集器**

达到一个可控制的吞吐量，提供了两个参数精确控制吞吐量：
- -XX:MaxGCPauseMillis: 最大垃圾收集停顿时间

        范围：大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值

        停顿时间以吞吐量和新生代空间为代价换取，设置的越小，新生代空间则越小，GC发生的频率越多：

        原本10秒一次GC，一次100毫秒 -> 5秒一次GC，一次70毫秒

        =》每十秒100毫秒STW -> 每十秒140毫秒STW

        延迟降低，但吞吐量也随之变小

- -XX:GCTimeRatio：GC时间占总时间比率

        范围：0 - 100

        垃圾收集时间占总时间的比率，相当于吞吐量的倒数：值越大，则单次GC时间越小，吞吐量越低

- -XX:+UseAdaptiveSizePolicy: 自适应大小策略


实现算法：标记-复制算法，Scavenge/copying GC （并行版本）

#### **2. 老年代收集器**

HotSpot VM的GC里，除了CMS的concurrent collection之外，**其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事前触发一次young gc（除了Parallel Scavenge框架）**

#### **2.1 SerialOld**

串行化老年代收集算法

实现算法；标记-整理算法

#### **2.2 Parallel Old收集器**

并行化了老年代的标记-整理算法，不然之前用的PS MarkSweep，老年代回收效率低下，单次GC时间与总体GC时间都较大，影响了整体的吞吐量

实现算法：标记-整理算法

#### **2.3 CMS收集器**

一款以获取**最短回收停顿时间**为目标的收集器（低延迟），全称Concurrent Mark Sweep，即**并发安全**的**标记清除算法**

真正的Old GC，Full GC之下需要搭配young GC，不会去搜集整堆

运作过程分为以下四个步骤：
1. 初始标记（CMS initial mark）
    
    仅仅只是标记一下GC Roots能直接关联到的对象

2. 并发标记（CMS concurrent mark）

    从GC Roots直接关联到的对象开始遍历整个对象图的过程，耗时较长

3. 重新标记（CMS remark）

    修正并发标记时，因程序继续运作导致的标记变动，CMS使用增量更新的方式（将有新增白色对象引用的黑色对象作为根重遍历一遍）

4. 并发清除（CMS concurrent sweep）

其中初始标记和重新标记两个步骤还是需要STW

并发清理过程中不需要STW也能保证安全的原因是：

**在决定清除的那一刻已经不会有新的白色对象引用到黑色对象，因为GC Roots已经固定了，不可能再有黑色对象突然引用到白色对象上**

缺点：

1. 对处理器资源敏感，占用一部分线程导致应用程序变慢，降低总吞吐量，CMS默认启动的回收线程是（处理器核心数量 + 3） / 4，只占用不超过25%的运算资源

2. 无法处理“浮动垃圾”，即在清理的过程中可能会产生新的垃圾，所以必须预留一部分空间供并发收集时的程序运作使用

3. 标记-清除，会导致内存碎片情况严重，使得大对象分配困难，在老年代内存足够的情况下也得进行Full GC

默认搭配：ParNew + CMS

实现算法：标记-清除算法

### 总结
young gen的标记回收策略都是：标记-复制算法（copying/scavenge）

-XX:+UseSerialGC: 

    串行化SerialGC + 串行化Serial Old GC（mark-compact）

    client模式下的默认回收策略

-XX:+UseConcurrentMarkSweep: 

    并行化ParNewGC + 并发CMSGC（mark-sweep）

    第一款并发GC，专注于低延迟

-XX:+UseParallelGC/-XX:+UseParallelOldGC: 

    并行化PS Scavenge + 串行化PS MarkSweep/串行化PS Compact（mark-compact）

    吞吐量优先组合，老年代都是标记-整理算法

-XX:+UseG1GC



# 参考

- [深入理解JVM-3.5节经典垃圾收集器]()
- [HotSpot VM的开发历史和实现细节](https://hllvm-group.iteye.com/group/topic/37095#post-242695)