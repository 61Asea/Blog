# 跳表

说到在有序序列中查找某元素，大部分人第一反映都是**数组的N分查找**；说到维护一个支持插入操作的有序序列，大部分人第一反映都是**链表**，因为其插入的开销低，无需像数组一样移动后续的元素

融合了以上两种优势的结构，即能以**O(logN)时间级查找链表的元素**，就是跳表

跳表，全称为跳跃列表，是基于**有序的单向链表**演化而来的一种复合数据结构，通过在底层链表上维护多层索引来加速查找效率

它是一种以空间换时间的策略，额外增加的索引层也会占据额外的内存空间

    经常使用的平衡数据结构有：B树，红黑树，AVL树，Splay Tree, Treep等。想象一下，给你一张草稿纸，一只笔，一个编辑器，你能立即实现一颗红黑树，或者AVL树出来吗？

    用跳表吧，跳表是一种随机化的数据结构，目前开源软件 Redis 和 LevelDB 都有用到它，它的效率和红黑树以及 AVL 树不相上下，但跳表的原理相当简单，只要你能熟练操作链表，就能轻松实现一个 SkipList

# **1. 演化过程**

单向链表，即使是已排好序的，在遍历时也能只能从头开始，效率较低，时间为O(N)

跳表通过对链表添加多级索引，形成**多层次的链表**。每一层的链表中的元素，都是底层链表元素的子集，也是后一层链表元素的子集

    上一层链表：
    node1 -> node4 -> node6

    底层链表：
    node1 -> node2 -> node3 -> node4 -> node5 -> node6

一开始，算法在**最稀疏的一层开始搜索**，直至给定的查找K处于该层两个相邻元素之间，或者该层的某个元素。如果就是该层的某个元素，则查找成功；如果是相邻元素之间，**算法将跳转到下一个层次**，重复上述过程，直至在某一层找到真正的元素为止

# **2. 效率**

假设每a个结点间隔，建立一个索引，则：
第一层的结点数：n/a
第二层的结点数：n/a^2
第三层的结点数：n/a^3
第m层的结点数：n/a^m

所以给定最上层的结点数预估值为也为a，可以得到m的层数大小：

    n/a^m = a
    =>
    a^(m + 1) = n
    =>
    m = loga(n) -1

链表的总层数为：m + 1 = loga(n)，如果平均每一层都需要遍历k个结点，则可以得出最终的时间复杂度为：

    O(K*loga(N)) => O(logN)

因为链表的插入和删除很快，相当于比查询多了一个操作，所以得出结论：

    查询，插入，删除的效率都为O(logN)

# **3. 关键行为**

    涉及到队列操作的链表，应是双向链表，因为在直接队尾执行入队操作时，需要将队尾的前驱结点的next引用指向null，但是如果使用单向链表，将无法获取队尾的前驱结点

ConcurrentSkipListMap上的链表是单向链表，因为其没有涉及到头插/尾插和出队的需求

> [ConcurrentSkipListMap](https://asea-cch.life/achrives/concurrentskiplistmap)

## **3.1 插入**

因为插入本质上不会影响到索引层，只是增加了一次索引层映射到底层链表遍历的次数

根据指定位置/元素的插入：跳表的查询次数 + 1

### **平衡性问题**

如果频繁地向链表插入元素，但是这些元素并没有良好的分布情况，将会出现聚集情况，导致某个索引间的元素过满，这将使得索引的效果变差

所以需要维护索引和原始链表之间的大小平衡关系，即结点增加了，则索引也应重新建立，变得更多和更加均匀

## **3.2 删除**

如果删除的元素恰好是某个索引层的索引元素，我们还需要删除掉索引层相关该元素

根据指定位置/元素的删除：跳表的查询次数 + 有该结点的层数

# 参考
- [数据结构与算法——跳表](https://zhuanlan.zhihu.com/p/68516038)
- [SkipList的基本原理](https://www.cnblogs.com/lfri/p/9991925.html)