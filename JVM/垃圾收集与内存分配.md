### **垃圾收集与内存分配**

- 哪些内存需要回收？
- 什么时候回收？
- 怎么回收？

虚拟机栈/计数器/本地方法栈，生命周期与线程重合，这几个区域的内存分配（编译期已知栈帧大小）和回收（线程死亡）都具备确定性

堆和方法区具有动态性质，无法确定大小，一个接口的多个实现类所需要的内存大小可能不同，执行的方法需要的内存也不一样

#### **1. 对象”死亡“**

指的是对象不可能再被任何途径使用（GC Roots无法到达）

#### **1.1 引用计数法**

在对象中占用额外的内存空间，添加一个引用计数器，每当一个地方引用它，则计数器+1；当引用失效时，计数器-1；

**任何时刻计数器为零的对象就是不可能再被使用的**

- 优点：

    判定效率极高，原理简单

- 问题：

    需要额外考虑很多例外情况，配合大量的额外处理，很难解决**对象之间的相互引用问题**

#### **1.2 可达性分析（重点）**

通过一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”

如果某个对象到GC Roots间没有任何引用链相连，或者用图论而言，**GcRoots到这个节点不可达时**，则证明该对象不可能再被使用

    tracing GC的本质是通过找出所有活对象来把其余空间认定为“无用”，而不是找出所有死掉的对象并回收它们占用的空间

#### **GC Roots**

GC Roots，或者说tracing GC的根节点，就是**一组必须活跃的引用**（必须要能完整枚举出所有GC Roots，否则就可能漏扫描活跃的对象，导致活跃对象错误回收）

固定可作为GC Roots的对象包括以下几种：
- 在**虚拟机栈（局部变量表）引用的对象**，譬如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等

    **所有Java线程当前活跃栈帧里指向GC堆里的对象的引用，即当前所有正在被调用的方法的引用类型的参数/局部变量/临时值**

- 在**方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量**
- 在**方法区中常量引用的对象，譬如字符串常量池的引用**
- 在本地方法栈中JNI（Native方法）引用的对象
- Java虚拟机内部的引用，如基本数据类型对于的Class对象，一些常驻的异常对象，**系统类加载器**
- **所有被同步锁持有的对象**
- 反映Java虚拟机内部情况的JMXBean/JVMTI中注册的回调、本地代码缓存等

除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以又其他对象临时性地加入，共同构成完整的GC Roots集合：

    基于分代式GC的部分收集做法，在执行部分收集时，从GC堆非收集部分指向收集部分的引用（即非收集部分对象有收集部分对象的引用），则该引用也必须作为GC Roots的一部分



